# Comparing `tmp/routingpy-1.2.1-py3-none-any.whl.zip` & `tmp/routingpy-1.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,30 @@
-Zip file size: 80587 bytes, number of entries: 27
--rw-r--r--  2.0 unx     1486 b- defN 23-Apr-22 21:45 routingpy/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Apr-22 21:45 routingpy/__version__.py
--rw-r--r--  2.0 unx     7857 b- defN 23-Apr-22 21:45 routingpy/client_base.py
--rw-r--r--  2.0 unx     8715 b- defN 23-Apr-22 21:45 routingpy/client_default.py
--rw-r--r--  2.0 unx     2230 b- defN 23-Apr-22 21:45 routingpy/convert.py
--rw-r--r--  2.0 unx     3761 b- defN 23-Apr-22 21:45 routingpy/direction.py
--rw-r--r--  2.0 unx     2051 b- defN 23-Apr-22 21:45 routingpy/exceptions.py
--rw-r--r--  2.0 unx     4527 b- defN 23-Apr-22 21:45 routingpy/expansion.py
--rw-r--r--  2.0 unx     3002 b- defN 23-Apr-22 21:45 routingpy/isochrone.py
--rw-r--r--  2.0 unx     2600 b- defN 23-Apr-22 21:45 routingpy/matrix.py
--rw-r--r--  2.0 unx     4070 b- defN 23-Apr-22 21:45 routingpy/utils.py
--rw-r--r--  2.0 unx    12312 b- defN 23-Apr-22 21:45 routingpy/valhalla_attributes.py
--rw-r--r--  2.0 unx     3101 b- defN 23-Apr-22 21:45 routingpy/routers/__init__.py
--rw-r--r--  2.0 unx    21028 b- defN 23-Apr-22 21:45 routingpy/routers/google.py
--rw-r--r--  2.0 unx    25096 b- defN 23-Apr-22 21:45 routingpy/routers/graphhopper.py
--rw-r--r--  2.0 unx    63224 b- defN 23-Apr-22 21:45 routingpy/routers/heremaps.py
--rw-r--r--  2.0 unx    20907 b- defN 23-Apr-22 21:45 routingpy/routers/mapbox_osrm.py
--rw-r--r--  2.0 unx     3116 b- defN 23-Apr-22 21:45 routingpy/routers/mapbox_valhalla.py
--rw-r--r--  2.0 unx    21799 b- defN 23-Apr-22 21:45 routingpy/routers/openrouteservice.py
--rw-r--r--  2.0 unx    16183 b- defN 23-Apr-22 21:45 routingpy/routers/osrm.py
--rw-r--r--  2.0 unx    37388 b- defN 23-Apr-22 21:45 routingpy/routers/valhalla.py
--rw-r--r--  2.0 unx      110 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/AUTHORS.md
--rw-r--r--  2.0 unx    11357 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/LICENSE
--rw-r--r--  2.0 unx    15174 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2243 b- defN 23-Apr-22 21:45 routingpy-1.2.1.dist-info/RECORD
-27 files, 293461 bytes uncompressed, 77003 bytes compressed:  73.8%
+Zip file size: 84433 bytes, number of entries: 28
+-rw-r--r--  2.0 unx     1481 b- defN 23-Aug-03 09:11 routingpy/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Aug-03 09:11 routingpy/__version__.py
+-rw-r--r--  2.0 unx     7857 b- defN 23-Aug-03 09:11 routingpy/client_base.py
+-rw-r--r--  2.0 unx     9018 b- defN 23-Aug-03 09:11 routingpy/client_default.py
+-rw-r--r--  2.0 unx     3000 b- defN 23-Aug-03 09:11 routingpy/convert.py
+-rw-r--r--  2.0 unx     3877 b- defN 23-Aug-03 09:11 routingpy/direction.py
+-rw-r--r--  2.0 unx     2064 b- defN 23-Aug-03 09:11 routingpy/exceptions.py
+-rw-r--r--  2.0 unx     4659 b- defN 23-Aug-03 09:11 routingpy/expansion.py
+-rw-r--r--  2.0 unx     3194 b- defN 23-Aug-03 09:11 routingpy/isochrone.py
+-rw-r--r--  2.0 unx     2710 b- defN 23-Aug-03 09:11 routingpy/matrix.py
+-rw-r--r--  2.0 unx     1411 b- defN 23-Aug-03 09:11 routingpy/raster.py
+-rw-r--r--  2.0 unx     4070 b- defN 23-Aug-03 09:11 routingpy/utils.py
+-rw-r--r--  2.0 unx    12259 b- defN 23-Aug-03 09:11 routingpy/valhalla_attributes.py
+-rw-r--r--  2.0 unx     3194 b- defN 23-Aug-03 09:11 routingpy/routers/__init__.py
+-rw-r--r--  2.0 unx    21548 b- defN 23-Aug-03 09:11 routingpy/routers/google.py
+-rw-r--r--  2.0 unx    26114 b- defN 23-Aug-03 09:11 routingpy/routers/graphhopper.py
+-rw-r--r--  2.0 unx    65415 b- defN 23-Aug-03 09:11 routingpy/routers/heremaps.py
+-rw-r--r--  2.0 unx    21764 b- defN 23-Aug-03 09:11 routingpy/routers/mapbox_osrm.py
+-rw-r--r--  2.0 unx    22668 b- defN 23-Aug-03 09:11 routingpy/routers/openrouteservice.py
+-rw-r--r--  2.0 unx    12152 b- defN 23-Aug-03 09:11 routingpy/routers/opentripplanner_v2.py
+-rw-r--r--  2.0 unx    16712 b- defN 23-Aug-03 09:11 routingpy/routers/osrm.py
+-rw-r--r--  2.0 unx    36872 b- defN 23-Aug-03 09:11 routingpy/routers/valhalla.py
+-rw-r--r--  2.0 unx      110 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/AUTHORS.md
+-rw-r--r--  2.0 unx    11357 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    15205 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2323 b- defN 23-Aug-03 09:11 routingpy-1.3.0.dist-info/RECORD
+28 files, 311158 bytes uncompressed, 80729 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -24,14 +24,17 @@
 
 Filename: routingpy/isochrone.py
 Comment: 
 
 Filename: routingpy/matrix.py
 Comment: 
 
+Filename: routingpy/raster.py
+Comment: 
+
 Filename: routingpy/utils.py
 Comment: 
 
 Filename: routingpy/valhalla_attributes.py
 Comment: 
 
 Filename: routingpy/routers/__init__.py
@@ -45,38 +48,38 @@
 
 Filename: routingpy/routers/heremaps.py
 Comment: 
 
 Filename: routingpy/routers/mapbox_osrm.py
 Comment: 
 
-Filename: routingpy/routers/mapbox_valhalla.py
+Filename: routingpy/routers/openrouteservice.py
 Comment: 
 
-Filename: routingpy/routers/openrouteservice.py
+Filename: routingpy/routers/opentripplanner_v2.py
 Comment: 
 
 Filename: routingpy/routers/osrm.py
 Comment: 
 
 Filename: routingpy/routers/valhalla.py
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/AUTHORS.md
+Filename: routingpy-1.3.0.dist-info/AUTHORS.md
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/LICENSE
+Filename: routingpy-1.3.0.dist-info/LICENSE
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/METADATA
+Filename: routingpy-1.3.0.dist-info/METADATA
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/WHEEL
+Filename: routingpy-1.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/top_level.txt
+Filename: routingpy-1.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: routingpy-1.2.1.dist-info/RECORD
+Filename: routingpy-1.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## routingpy/__init__.py

```diff
@@ -19,15 +19,15 @@
 
 Using **routingpy** you can easily request **directions**, **isochrones** and
 **matrices** from many reliable online providers in a consistent fashion. Base parameters
 are the same for all services, while still preserving each service's special parameters (for
 more info, please look at our `README`_.
 Take a look at our `Examples`_ to see how simple you can compare routes from different providers.
 
-**routingpy** is tested against 3.7, 3.8, 3.9, 3.10, 3.11 :strike:`and PyPy3` (`#60 <https://github.com/gis-ops/routing-py/issues/60>`_).
+**routingpy** is tested against 3.8, 3.9, 3.10, 3.11 :strike:`and PyPy3` (`#60 <https://github.com/gis-ops/routing-py/issues/60>`_).
 
 .. _`README`: https://github.com/gis-ops/routing-py#api
 .. _`Examples`: https://github.com/gis-ops/routing-py#examples
 """
 
 from .routers import *  # noqa: F401
```

## routingpy/__version__.py

```diff
@@ -1 +1 @@
-__version__ = "1.2.1"
+__version__ = "1.3.0"
```

## routingpy/client_default.py

```diff
@@ -11,14 +11,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 
+import copy
 import json
 import random
 import time
 import warnings
 from datetime import datetime
 
 import requests
@@ -130,16 +131,16 @@
         :raises routingpy.exceptions.RouterServerError: when the API returns a server error.
         :raises routingpy.exceptions.RouterError: when anything else happened while requesting.
         :raises routingpy.exceptions.JSONParseError: when the JSON response can't be parsed.
         :raises routingpy.exceptions.Timeout: when the request timed out.
         :raises routingpy.exceptions.TransportError: when something went wrong while trying to
             execute a request.
 
-        :returns: raw JSON response.
-        :rtype: dict
+        :returns: raw JSON response or GeoTIFF image
+        :rtype: dict or bytes
         """
 
         if not first_request_time:
             first_request_time = datetime.now()
 
         elapsed = datetime.now() - first_request_time
         if elapsed > self.retry_timeout:
@@ -152,15 +153,15 @@
             delay_seconds = 1.5 ** (retry_counter - 1)
 
             # Jitter this value by 50% and pause.
             time.sleep(delay_seconds * (random.random() + 0.5))
 
         authed_url = self._generate_auth_url(url, get_params)
 
-        final_requests_kwargs = self.kwargs
+        final_requests_kwargs = copy.copy(self.kwargs)
 
         # Determine GET/POST.
         requests_method = self._session.get
         if post_params is not None:
             requests_method = self._session.post
             if final_requests_kwargs["headers"]["Content-Type"] == "application/json":
                 final_requests_kwargs["json"] = post_params
@@ -188,21 +189,18 @@
 
         if response.status_code in _RETRIABLE_STATUSES:
             # Retry request.
             warnings.warn(
                 "Server down.\nRetrying for the {}{} time.".format(tried, get_ordinal(tried)),
                 UserWarning,
             )
-
             return self._request(url, get_params, post_params, first_request_time, retry_counter + 1)
 
         try:
-            result = self._get_body(response)
-
-            return result
+            return self._get_body(response)
 
         except exceptions.RouterApiError:
             if self.skip_api_error:
                 warnings.warn(
                     "Router {} returned an API error with "
                     "the following message:\n{}".format(self.__class__.__name__, response.text)
                 )
@@ -225,26 +223,33 @@
     def req(self):
         """Holds the :class:`requests.PreparedRequest` property for the last request."""
         return self._req
 
     @staticmethod
     def _get_body(response):
         status_code = response.status_code
+        content_type = response.headers["content-type"]
 
-        try:
-            body = response.json()
-        except json.decoder.JSONDecodeError:
-            raise exceptions.JSONParseError("Can't decode JSON response:{}".format(response.text))
+        if status_code == 200:
+            if content_type == "image/tiff":
+                return response.content
+
+            else:
+                try:
+                    return response.json()
+
+                except json.decoder.JSONDecodeError:
+                    raise exceptions.JSONParseError(
+                        "Can't decode JSON response:{}".format(response.text)
+                    )
 
         if status_code == 429:
-            raise exceptions.OverQueryLimit(status_code, body)
+            raise exceptions.OverQueryLimit(status_code, response.text)
 
         if 400 <= status_code < 500:
-            raise exceptions.RouterApiError(status_code, body)
+            raise exceptions.RouterApiError(status_code, response.text)
 
         if 500 <= status_code:
-            raise exceptions.RouterServerError(status_code, body)
+            raise exceptions.RouterServerError(status_code, response.text)
 
         if status_code != 200:
-            raise exceptions.RouterError(status_code, body)
-
-        return body
+            raise exceptions.RouterError(status_code, response.text)
```

## routingpy/convert.py

```diff
@@ -12,14 +12,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """Converts Python types to string representations suitable for GET queries.
 """
+import datetime
 
 
 def delimit_list(arg, delimiter=","):
     """Convert list to delimiter-separated string"""
     if not is_list(arg):
         raise TypeError("Expected a list or tuple, " "but got {}".format(type(arg).__name__))
     return delimiter.join(map(str, arg))
@@ -72,7 +73,38 @@
 
     :param method: the method name
     :type method: string
 
     :rtype: bool
     """
     return hasattr(arg, method) and callable(getattr(arg, method))
+
+
+def seconds_to_iso8601(seconds):
+    """Convert the given number of seconds to ISO 8601 duration format.
+
+    Example:
+        >>> seconds_to_iso8601(3665)
+        'PT1H1M5S'
+
+    :param seconds: The number of seconds to convert.
+    :type seconds: int
+
+    :returns: The duration in ISO 8601 format.
+    :rtype: string
+    """
+    duration = datetime.timedelta(seconds=seconds)
+    hours = duration.seconds // 3600
+    minutes = (duration.seconds // 60) % 60
+    seconds = duration.seconds % 60
+
+    iso8601_duration = "PT"
+    if hours:
+        iso8601_duration += f"{hours}H"
+
+    if minutes:
+        iso8601_duration += f"{minutes}M"
+
+    if seconds or not (hours or minutes):
+        iso8601_duration += f"{seconds}S"
+
+    return iso8601_duration
```

## routingpy/direction.py

```diff
@@ -13,14 +13,15 @@
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """
 :class:`.Direction` returns directions results.
 """
+from typing import List, Optional
 
 
 class Directions(object):
     """
     Contains a list of :class:`Direction`, when the router returned multiple alternative routes, and the complete raw
     response, which can be accessed via the property ``raw``.
     """
@@ -35,15 +36,15 @@
         :param raw: The whole raw directions response of the routing engine.
         :type raw: dict
         """
         self._directions = directions
         self._raw = raw
 
     @property
-    def raw(self):
+    def raw(self) -> Optional[dict]:
         """
         Returns the directions raw, unparsed response. For details, consult the routing engine's API documentation.
         :rtype: dict or None
         """
         return self._raw
 
     def __repr__(self):  # pragma: no cover
@@ -57,15 +58,15 @@
 
     def __len__(self):
         return len(self._directions)
 
 
 class Direction(object):
     """
-    Contains a parsed directions response. Access via properties ``geometry``, ``duration`` and ``distance``.
+    Contains a parsed directions' response. Access via properties ``geometry``, ``duration`` and ``distance``.
     """
 
     def __init__(self, geometry=None, duration=None, distance=None, raw=None):
         """
         Initialize a :class:`Direction` object to hold the properties of a directions request.
 
         :param geometry: The geometry list in [[lon1, lat1], [lon2, lat2]] order.
@@ -83,42 +84,42 @@
         """
         self._geometry = geometry
         self._duration = duration
         self._distance = distance
         self._raw = raw
 
     @property
-    def geometry(self):
+    def geometry(self) -> Optional[List[List[float]]]:
         """
         The geometry of the route as [[lon1, lat1], [lon2, lat2], ...] list.
 
         :rtype: list or None
         """
         return self._geometry
 
     @property
-    def duration(self):
+    def duration(self) -> int:
         """
         The duration of the entire trip in seconds.
 
         :rtype: int
         """
         return self._duration
 
     @property
-    def distance(self):
+    def distance(self) -> int:
         """
         The distance of the entire trip in meters.
 
         :rtype: int
         """
         return self._distance
 
     @property
-    def raw(self):
+    def raw(self) -> Optional[dict]:
         """
         Returns the route's raw, unparsed response. For details, consult the routing engine's API documentation.
 
         :rtype: dict or None
         """
         return self._raw
```

## routingpy/exceptions.py

```diff
@@ -11,15 +11,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """
-Defines exceptions that are thrown by the ORS client.
+Defines exceptions that are thrown by the various routing clients.
 """
 
 
 class RouterError(Exception):  # pragma: no cover
     """Represents an exception returned by the remote or local API."""
 
     def __init__(self, status, message=None):
```

## routingpy/expansion.py

```diff
@@ -33,60 +33,60 @@
         self._distance = distances
         self._duration = durations
         self._cost = costs
         self._edge_id = edge_ids
         self._status = statuses
 
     @property
-    def geometry(self):
+    def geometry(self) -> Optional[List[List[float]]]:
         """
         The geometry of the edge as [[lon1, lat1], [lon2, lat2]] list.
 
         :rtype: list or None
         """
         return self._geometry
 
     @property
-    def distance(self):
+    def distance(self) -> Optional[int]:
         """
         The accumulated distance in meters for the edge in order of graph traversal.
 
         :rtype: int or None
         """
         return self._distance
 
     @property
-    def duration(self):
+    def duration(self) -> Optional[int]:
         """
         The accumulated duration in seconds for the edge in order of graph traversal.
 
         :rtype: int or None
         """
         return self._duration
 
     @property
-    def cost(self):
+    def cost(self) -> Optional[int]:
         """
         The accumulated cost for the edge in order of graph traversal.
 
         :rtype: int or None
         """
         return self._cost
 
     @property
-    def edge_id(self):
+    def edge_id(self) -> Optional[int]:
         """
         The internal edge IDs for each edge in order of graph traversal.
 
         :rtype: int or None
         """
         return self._edge_id
 
     @property
-    def status(self):
+    def status(self) -> Optional[str]:
         """
         The edge states for each edge in order of graph traversal.
         Can be one of "r" (reached), "s" (settled), "c" (connected).
 
         :rtype: str or None
         """
         return self._status
@@ -124,24 +124,24 @@
         return self._raw
 
     @property
     def center(self) -> Optional[Union[List[float], Tuple[float]]]:
         """
         The center coordinate in [lon, lat] of the expansion, which is the location from the user input.
 
-        :rtype: list of float
+        :rtype: list of float or None
         """
         return self._center
 
     @property
     def interval_type(self) -> Optional[str]:
         """
         Was it based on 'distance' or 'time'?
 
-        :return: str
+        :return: str or None
         """
         return self._interval_type
 
     def __repr__(self):  # pragma: no cover
         if len(self._edges) < 10:
             return "Expansions({}, {})".format(self._edges, self.raw)
         else:
```

## routingpy/isochrone.py

```diff
@@ -11,32 +11,33 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """
-:class:`Isochrone` returns directions results.
+:class:`Isochrone` returns isochrones results.
 """
+from typing import List, Optional, Tuple, Union
 
 
 class Isochrones(object):
     """
     Contains a list of :class:`Isochrone`, which can be iterated over or accessed by index. The property Â¸`raw`` contains
     the complete raw response of the isochrones request.
     """
 
     def __init__(self, isochrones=None, raw=None):
         self._isochrones = isochrones
         self._raw = raw
 
     @property
-    def raw(self):
+    def raw(self) -> Optional[dict]:
         """
-        Returns the isochrones's raw, unparsed response. For details, consult the routing engine's API documentation.
+        Returns the isochrones' raw, unparsed response. For details, consult the routing engine's API documentation.
 
         :rtype: dict or None
         """
         return self._raw
 
     def __repr__(self):  # pragma: no cover
         return "Isochrones({}, {})".format(self._isochrones, self.raw)
@@ -59,46 +60,46 @@
     def __init__(self, geometry=None, interval=None, center=None, interval_type=None):
         self._geometry = geometry
         self._interval = int(interval)
         self._center = center
         self._interval_type = interval_type
 
     @property
-    def geometry(self):
+    def geometry(self) -> Optional[List[List[float]]]:
         """
         The geometry of the isochrone as [[lon1, lat1], [lon2, lat2], ...] list.
 
         :rtype: list or None
         """
         return self._geometry
 
     @property
-    def center(self):
+    def center(self) -> Optional[Union[List[float], Tuple[float]]]:
         """
         The center coordinate in [lon, lat] of the isochrone. Might deviate from the input coordinate.
         Not available for all routing engines (e.g. GraphHopper, Mapbox OSRM or Valhalla).
         In this case, it will use the location from the user input.
 
-        :rtype: list of float
+        :rtype: list of float or None
         """
         return self._center
 
     @property
-    def interval(self):
+    def interval(self) -> Optional[int]:
         """
         The interval of the isochrone in seconds or in meters.
 
         :return: int
         """
         return self._interval
 
     @property
-    def interval_type(self):
+    def interval_type(self) -> Optional[str]:
         """
         Was it based on 'distance' or 'time'?
 
-        :return: str
+        :return: str or None
         """
         return self._interval_type
 
     def __repr__(self):  # pragma: no cover
         return "Isochrone({}, {})".format(self.geometry, self.interval)
```

## routingpy/matrix.py

```diff
@@ -11,30 +11,31 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """
-:class:`Matrix` returns directions results.
+:class:`Matrix` returns matrix results.
 """
+from typing import List, Optional
 
 
 class Matrix(object):
     """
     Contains a parsed matrix response. Access via properties ``geometry`` and ``raw``.
     """
 
     def __init__(self, durations=None, distances=None, raw=None):
         self._durations = durations
         self._distances = distances
         self._raw = raw
 
     @property
-    def durations(self):
+    def durations(self) -> Optional[List[List[float]]]:
         """
         The durations matrix as list akin to::
 
             [
                 [
                     duration(origin1-destination1),
                     duration(origin1-destination2),
@@ -42,24 +43,24 @@
                     ...
                 ],
                 [
                     duration(origin2-destination1),
                     duration(origin2-destination2),
                     duration[origin3-destination3),
                     ...
-                },
+                ],
                 ...
             ]
 
         :rtype: list or None
         """
         return self._durations
 
     @property
-    def distances(self):
+    def distances(self) -> Optional[List[List[float]]]:
         """
         The distance matrix as list akin to::
 
             [
                 [
                     duration(origin1-destination1),
                     duration(origin1-destination2),
@@ -67,24 +68,24 @@
                     ...
                 ],
                 [
                     duration(origin2-destination1),
                     duration(origin2-destination2),
                     duration[origin3-destination3),
                     ...
-                },
+                ],
                 ...
             ]
 
         :rtype: list or None
         """
         return self._distances
 
     @property
-    def raw(self):
+    def raw(self) -> Optional[dict]:
         """
         Returns the matrices raw, unparsed response. For details, consult the routing engine's API documentation.
 
         :rtype: dict or None
         """
         return self._raw
```

## routingpy/valhalla_attributes.py

```diff
@@ -10,17 +10,15 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
-"""
-:class:`Expansion` returns expansion results.
-"""
+
 from enum import Enum
 from typing import List, Optional, Tuple, Union
 
 from routingpy.utils import decode_polyline6
 
 
 class MatchDiscontinuity(str, Enum):
```

## routingpy/routers/__init__.py

```diff
@@ -16,36 +16,37 @@
 """
 from ..client_base import options  # noqa: F401
 from ..exceptions import RouterNotFound
 from .google import Google
 from .graphhopper import Graphhopper
 from .heremaps import HereMaps
 from .mapbox_osrm import MapboxOSRM
-from .mapbox_valhalla import MapboxValhalla
 from .openrouteservice import ORS
+from .opentripplanner_v2 import OpenTripPlannerV2
 from .osrm import OSRM
 from .valhalla import Valhalla
 
 # Provide synonyms
 _SERVICE_TO_ROUTER = {
-    "ors": ORS,
-    "openrouteservice": ORS,
-    "osrm": OSRM,
+    "google": Google,
+    "graphhopper": Graphhopper,
+    "here": HereMaps,
+    "heremaps": HereMaps,
     "mapbox_osrm": MapboxOSRM,
     "mapbox-osrm": MapboxOSRM,
-    "mapboxosrm": MapboxOSRM,
     "mapbox": MapboxOSRM,
+    "mapboxosrm": MapboxOSRM,
+    "openrouteservice": ORS,
+    "opentripplanner": OpenTripPlannerV2,
+    "opentripplanner_v2": OpenTripPlannerV2,
+    "ors": ORS,
+    "osrm": OSRM,
+    "otp": OpenTripPlannerV2,
+    "otp_v2": OpenTripPlannerV2,
     "valhalla": Valhalla,
-    "mapbox_valhalla": MapboxValhalla,
-    "mapbox-valhalla": MapboxValhalla,
-    "mapboxvalhalla": MapboxValhalla,
-    "graphhopper": Graphhopper,
-    "google": Google,
-    "here": HereMaps,
-    "heremaps": HereMaps,
 }
 
 
 def get_router_by_name(router_name):
     """
     Given a router's name, try to return the router class.
 
@@ -57,15 +58,15 @@
 
     If the string given is not recognized, a
     :class:`routingpy.exceptions.RouterNotFound` exception is raised and the available list of router names is printed.
 
     :param router_name: Name of the router as string.
     :type router_name: str
 
-    :rtype: Union[:class:`routingpy.routers.google.Google`, :class:`routingpy.routers.graphhopper.Graphhopper`, :class:`routingpy.routers.heremaps.HereMaps`, :class:`routingpy.routers.mapbox_osrm.MapBoxOSRM`, :class:`routingpy.routers.mapbox_valhalla.MapBoxValhalla`, :class:`routingpy.routers.openrouteservice.ORS`, :class:`routingpy.routers.osrm.OSRM`, :class:`routingpy.routers.valhalla.Valhalla`]
+    :rtype: Union[:class:`routingpy.routers.google.Google`, :class:`routingpy.routers.graphhopper.Graphhopper`, :class:`routingpy.routers.heremaps.HereMaps`, :class:`routingpy.routers.mapbox_osrm.MapBoxOSRM`, :class:`routingpy.routers.mapbox_valhalla.MapBoxValhalla`, :class:`routingpy.routers.openrouteservice.ORS`, :class:`routingpy.routers.osrm.OSRM`, :class:`routingpy.routers.otp_v2.OpenTripPlannerV2`, :class:`routingpy.routers.valhalla.Valhalla`]
 
     """
     try:
         return _SERVICE_TO_ROUTER[router_name.lower()]
     except KeyError:
         raise RouterNotFound(
             "Unknown router '{}'; options are: {}".format(router_name, _SERVICE_TO_ROUTER.keys())
```

## routingpy/routers/google.py

```diff
@@ -12,14 +12,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 
 from operator import itemgetter
+from typing import List, Optional, Tuple, Union
 
 from .. import convert, utils
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..exceptions import OverQueryLimit, RouterApiError, RouterServerError
 from ..matrix import Matrix
@@ -67,20 +68,20 @@
 class Google:
     """Performs requests to the Google API services."""
 
     _base_url = "https://maps.googleapis.com/maps/api"
 
     def __init__(
         self,
-        api_key,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
+        api_key: str,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
         retry_over_query_limit=True,
-        skip_api_error=None,
+        skip_api_error: Optional[bool] = None,
         client=Client,
         **client_kwargs
     ):
         """
         Initializes a Google client.
 
         :param api_key: API key.
@@ -173,28 +174,28 @@
             if not self.stopover:
                 waypoint = "via:" + waypoint
 
             return waypoint
 
     def directions(  # noqa: C901
         self,
-        locations,
-        profile,
-        alternatives=None,
-        avoid=None,
-        optimize=None,
-        language=None,
-        region=None,
-        units=None,
-        arrival_time=None,
-        departure_time=None,
-        traffic_model=None,
-        transit_mode=None,
-        transit_routing_preference=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        alternatives: Optional[bool] = None,
+        avoid: Optional[List[str]] = None,
+        optimize: Optional[bool] = None,
+        language: Optional[str] = None,
+        region: Optional[str] = None,
+        units: Optional[str] = None,
+        arrival_time: Optional[int] = None,
+        departure_time: Optional[int] = None,
+        traffic_model: Optional[str] = None,
+        transit_mode: Optional[Union[List[str], Tuple[str]]] = None,
+        transit_routing_preference: Optional[str] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Get directions between an origin point and a destination point.
 
         For more information, visit https://developers.google.com/maps/documentation/directions/intro.
 
         :param locations: The coordinates tuple the route should be calculated
             from in order of visit. Can be a list/tuple of [lon, lat], a list/tuple of address strings, Google's
@@ -361,44 +362,40 @@
                     )
                 )
             return Directions(routes, response)
         else:
             geometry = []
             duration, distance = 0, 0
             for leg in response["routes"][0]["legs"]:
-                duration = int(leg["duration"]["value"])
-                distance = int(leg["distance"]["value"])
+                duration += leg["duration"]["value"]
+                distance += leg["distance"]["value"]
                 for step in leg["steps"]:
-                    geometry.extend(
-                        [
-                            list(reversed(coords))
-                            for coords in utils.decode_polyline5(step["polyline"]["points"])
-                        ]
-                    )
+                    geometry.extend(utils.decode_polyline5(step["polyline"]["points"]))
+
             return Direction(geometry=geometry, duration=duration, distance=distance, raw=response)
 
     def isochrones(self):  # pragma: no cover
         raise NotImplementedError
 
     def matrix(  # noqa: C901
         self,
-        locations,
-        profile,
-        sources=None,
-        destinations=None,
-        avoid=None,
-        language=None,
-        region=None,
-        units=None,
-        arrival_time=None,
-        departure_time=None,
-        traffic_model=None,
-        transit_mode=None,
-        transit_routing_preference=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        sources: Optional[Union[List[int], Tuple[int]]] = None,
+        destinations: Optional[Union[List[int], Tuple[int]]] = None,
+        avoid: Optional[List[str]] = None,
+        language: Optional[str] = None,
+        region: Optional[str] = None,
+        units: Optional[str] = None,
+        arrival_time: Optional[int] = None,
+        departure_time: Optional[int] = None,
+        traffic_model: Optional[str] = None,
+        transit_mode: Optional[Union[List[str], Tuple[str]]] = None,
+        transit_routing_preference: Optional[str] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Gets travel distance and time for a matrix of origins and destinations.
 
         :param locations: Two or more pairs of lng/lat values.
         :type locations: list of list
 
         :param profile: The vehicle for which the route should be calculated.
```

## routingpy/routers/graphhopper.py

```diff
@@ -11,15 +11,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 
-from typing import List, Tuple  # noqa: F401
+from typing import List, Optional, Tuple, Union  # noqa: F401
 
 from .. import convert, utils
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..isochrone import Isochrone, Isochrones
 from ..matrix import Matrix
@@ -28,21 +28,21 @@
 class Graphhopper:
     """Performs requests to the Graphhopper API services."""
 
     _DEFAULT_BASE_URL = "https://graphhopper.com/api/1"
 
     def __init__(
         self,
-        api_key=None,
-        base_url=_DEFAULT_BASE_URL,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
+        api_key: Optional[str] = None,
+        base_url: Optional[str] = _DEFAULT_BASE_URL,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
         client=Client,
         **client_kwargs
     ):
         """
         Initializes an graphhopper client.
 
         :param api_key: GH API key. Required if https://graphhopper.com/api is used.
@@ -95,40 +95,40 @@
             retry_over_query_limit,
             skip_api_error,
             **client_kwargs
         )
 
     def directions(  # noqa: C901
         self,
-        locations,
-        profile,
-        format=None,
-        optimize=None,
-        instructions=None,
-        locale=None,
-        elevation=None,
-        points_encoded=True,
-        calc_points=None,
-        debug=None,
-        point_hints=None,
-        details=None,
-        ch_disable=None,
-        custom_model=None,
-        headings=None,
-        heading_penalty=None,
-        pass_through=None,
-        algorithm=None,
-        round_trip_distance=None,
-        round_trip_seed=None,
-        alternative_route_max_paths=None,
-        alternative_route_max_weight_factor=None,
-        alternative_route_max_share_factor=None,
-        dry_run=None,
-        snap_preventions=None,
-        curbsides=None,
+        locations: Union[List[List[float]], Tuple[Tuple[float]]],
+        profile: str,
+        format: Optional[str] = None,
+        optimize: Optional[bool] = None,
+        instructions: Optional[bool] = None,
+        locale: Optional[str] = None,
+        elevation: Optional[bool] = None,
+        points_encoded: Optional[bool] = True,
+        calc_points: Optional[bool] = None,
+        debug: Optional[bool] = None,
+        point_hints: Optional[List[str]] = None,
+        details: Optional[List[str]] = None,
+        ch_disable: Optional[bool] = None,
+        custom_model: Optional[dict] = None,
+        headings: Optional[List[int]] = None,
+        heading_penalty: Optional[int] = None,
+        pass_through: Optional[bool] = None,
+        algorithm: Optional[str] = None,
+        round_trip_distance: Optional[int] = None,
+        round_trip_seed: Optional[int] = None,
+        alternative_route_max_paths: Optional[int] = None,
+        alternative_route_max_weight_factor: Optional[float] = None,
+        alternative_route_max_share_factor: Optional[float] = None,
+        dry_run: Optional[bool] = None,
+        snap_preventions: Optional[List[str]] = None,
+        curbsides: Optional[List[str]] = None,
         **direction_kwargs
     ):
         """Get directions between an origin point and a destination point.
 
         Use ``direction_kwargs`` for any missing ``directions`` request options.
 
         For more information, visit https://docs.graphhopper.com/#operation/postRoute.
@@ -398,23 +398,23 @@
                 duration=int(response["paths"][0]["time"] / 1000),
                 distance=int(response["paths"][0]["distance"]),
                 raw=response,
             )
 
     def isochrones(
         self,
-        locations,
-        profile,
-        intervals,
-        type="json",
-        buckets=1,
-        interval_type="time",
-        reverse_flow=None,
-        debug=None,
-        dry_run=None,
+        locations: Union[Tuple[float], List[float]],
+        profile: str,
+        intervals: Union[List[int], Tuple[int]],
+        type: Optional[str] = "json",
+        buckets: Optional[int] = 1,
+        interval_type: Optional[str] = "time",
+        reverse_flow: Optional[bool] = None,
+        debug: Optional[bool] = None,
+        dry_run: Optional[bool] = None,
         **isochrones_kwargs
     ):
         """Gets isochrones or equidistants for a range of time/distance values around a given set of coordinates.
 
         Use ``isochrones_kwargs`` for missing ``isochrones`` request options.
 
         For more details visit https://docs.graphhopper.com/#tag/Isochrone-API.
@@ -512,21 +512,23 @@
                 )
             )
 
         return Isochrones(isochrones, response)
 
     def matrix(
         self,
-        locations,
-        profile,
-        sources=None,
-        destinations=None,
-        out_array=["times", "distances"],
+        locations: Union[
+            List[Union[List[float], Tuple[float]]], Tuple[Union[List[float], Tuple[float]]]
+        ],
+        profile: str,
+        sources: Optional[List[int]] = None,
+        destinations: Optional[List[int]] = None,
+        out_array: Optional[List[str]] = ["times", "distances"],
         debug=None,
-        dry_run=None,
+        dry_run: Optional[bool] = None,
         **matrix_kwargs
     ):
         """Gets travel distance and time for a matrix of origins and destinations.
 
         Use ``matrix_kwargs`` for any missing ``matrix`` request options.
 
         For more details visit https://docs.graphhopper.com/#tag/Matrix-API.
```

## routingpy/routers/heremaps.py

```diff
@@ -12,14 +12,15 @@
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 
 from operator import itemgetter
+from typing import List, Optional, Tuple, Union
 
 from .. import convert
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..isochrone import Isochrone, Isochrones
 from ..matrix import Matrix
@@ -27,22 +28,22 @@
 
 
 class HereMaps:
     """Performs requests to the HERE Maps API services."""
 
     def __init__(
         self,
-        app_id=None,
-        app_code=None,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
-        api_key=None,
+        app_id: Optional[str] = None,
+        app_code: Optional[str] = None,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
+        api_key: Optional[str] = None,
         client=Client,
         **client_kwargs
     ):
         """
         Initializes a HERE Maps client.
 
         :param app_id: HERE Maps app id.
@@ -230,67 +231,67 @@
                 for f, w in self.features.items():
                     get_features.append(convert.delimit_list([f, str(w)], ":"))
                 routing_mode.append(convert.delimit_list(get_features, ","))
             return convert.delimit_list(routing_mode, ";")
 
     def directions(  # noqa: C901
         self,
-        locations,
-        profile,
-        mode_type="fastest",
-        format="json",
-        request_id=None,
-        avoid_areas=None,
-        avoid_links=None,
-        avoid_seasonal_closures=None,
-        avoid_turns=None,
-        allowed_zones=None,
-        exclude_zones=None,
-        exclude_zone_types=None,
-        exclude_countries=None,
-        arrival=None,
-        departure=None,
-        alternatives=None,
-        metric_system=None,
-        view_bounds=None,
-        resolution=None,
-        instruction_format=None,
-        language=None,
-        json_attributes=None,
-        json_callback=None,
-        representation=None,
-        route_attributes=["waypoints", "summary", "shape", "boundingBox", "legs"],
-        leg_attributes=None,
-        maneuver_attributes=None,
-        link_attributes=None,
-        line_attributes=None,
-        generalization_tolerances=None,
-        vehicle_type=None,
-        license_plate=None,
-        max_number_of_changes=None,
-        avoid_transport_types=None,
-        walk_time_multiplier=None,
-        walk_speed=None,
-        walk_radius=None,
-        combine_change=None,
-        truck_type=None,
-        trailers_count=None,
-        shipped_hazardous_goods=None,
-        limited_weight=None,
-        weight_per_axle=None,
-        height=None,
-        width=None,
-        length=None,
-        tunnel_category=None,
-        truck_restriction_penalty=None,
-        return_elevation=None,
-        consumption_model=None,
-        custom_consumption_details=None,
-        speed_profile=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        mode_type: Optional[str] = "fastest",
+        format: Optional[str] = "json",
+        request_id: Optional[str] = None,
+        avoid_areas: Optional[List[List[List[float]]]] = None,
+        avoid_links: Optional[List[str]] = None,
+        avoid_seasonal_closures: Optional[bool] = None,
+        avoid_turns: Optional[str] = None,
+        allowed_zones: Optional[List[int]] = None,
+        exclude_zones: Optional[List[int]] = None,
+        exclude_zone_types: Optional[List[str]] = None,
+        exclude_countries: Optional[List[str]] = None,
+        arrival: Optional[str] = None,
+        departure: Optional[str] = None,
+        alternatives: Optional[int] = None,
+        metric_system: Optional[str] = None,
+        view_bounds: Optional[Union[List[float], Tuple[float]]] = None,
+        resolution: Optional[dict] = None,
+        instruction_format: Optional[str] = None,
+        language: Optional[str] = None,
+        json_attributes: Optional[int] = None,
+        json_callback: Optional[str] = None,
+        representation: Optional[List[str]] = None,
+        route_attributes: Optional[List[str]] = ["waypoints", "summary", "shape", "boundingBox", "legs"],
+        leg_attributes: Optional[List[str]] = None,
+        maneuver_attributes: Optional[List[str]] = None,
+        link_attributes: Optional[List[str]] = None,
+        line_attributes: Optional[List[str]] = None,
+        generalization_tolerances: Optional[List[float]] = None,
+        vehicle_type: Optional[str] = None,
+        license_plate: Optional[str] = None,
+        max_number_of_changes: Optional[int] = None,
+        avoid_transport_types: Optional[List[str]] = None,
+        walk_time_multiplier: Optional[float] = None,
+        walk_speed: Optional[float] = None,
+        walk_radius: Optional[int] = None,
+        combine_change: Optional[bool] = None,
+        truck_type: Optional[str] = None,
+        trailers_count: Optional[int] = None,
+        shipped_hazardous_goods: Optional[List[str]] = None,
+        limited_weight: Optional[int] = None,
+        weight_per_axle: Optional[int] = None,
+        height: Optional[int] = None,
+        width: Optional[int] = None,
+        length: Optional[int] = None,
+        tunnel_category: Optional[List[str]] = None,
+        truck_restriction_penalty: Optional[str] = None,
+        return_elevation: Optional[bool] = None,
+        consumption_model: Optional[str] = None,
+        custom_consumption_details: Optional[str] = None,
+        speed_profile: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **directions_kwargs
     ):
         """Get directions between an origin point and a destination point.
 
         Use ``direction_kwargs`` for any missing ``directions`` request options.
 
         For more information, https://developer.here.com/documentation/routing/topics/resource-calculate-route.html.
@@ -321,15 +322,15 @@
 
         :param avoid_areas: Areas which the route must not cross. Array of BoundingBox.
             Example with 2 bounding boxes
             https://developer.here.com/documentation/routing/topics/resource-param-type-bounding-box.html
         :type avoid_areas: list of list of list
 
         :param avoid_links: Links which the route must not cross. The list of LinkIdTypes.
-        :type avoid_areas: list of str
+        :type avoid_links: list of str
 
         :param avoid_seasonal_closures: The optional avoid seasonal closures boolean
             flag can be specified to avoid usage of seasonally closed links.
             Examples of seasonally closed links are roads that may be closed during the
             winter due to weather conditions or ferries that may be out of operation
             for the season (based on past closure dates).
         :type avoid_seasonal_closures: bool
@@ -353,15 +354,15 @@
         :param exclude_zone_types: List of zone types which the route must not
             cross under any circumstances.
             https://developer.here.com/documentation/routing/topics/resource-type-enumerations.html
             #resource-type-enumerations__enum-routing-zone-type-type
         :type exclude_zone_types: list of str
 
         :param exclude_countries: Countries that must be excluded from route calculation.
-        :type exclude_zone_types: list of str
+        :type exclude_countries: list of str
 
         :param departure: Time when travel is expected to start. Traffic speed and
             incidents are taken into account
             when calculating the route (note that in case of a past
             departure time the historical traffic is limited to one year).
             You can use now to specify the current time. Specify either departure
             or arrival, not both. When the optional timezone offset is not
@@ -462,15 +463,15 @@
         :param param vehicle_type: Specifies type of vehicle engine and average
             fuel consumption, which can be used to estimate CO2 emission for
             the route summary.
             https://developer.here.com/documentation/routing/topics/resource-param-type-vehicle-type.html
         :type vehicle_type: str
 
         :param param license_plate: Specifies fragments of vehicle's license plate number.
-            The lastcharacter is currently the only supported fragment type.
+            The last character is currently the only supported fragment type.
             The license plate parameter enables evaluation of license plate
             based vehicle restrictions like odd/even scheme in Indonesia.
         :type license_plate: str
 
         :param max_number_of_changes: Restricts number of changes in a public
             transport route to a given value. The parameter does not filter resulting
             alternatives. Instead, it affects route calculation so that only
@@ -525,15 +526,15 @@
 
         :param limited_weight: Truck routing only, vehicle weight including
             trailers and shipped goods, in tons. The provided value must be between 0 and 1000.
         :type limited_weight: int
 
         :param weight_per_axle: Truck routing only, vehicle weight per axle in
             tons. The provided value must be between 0 and 1000.
-        :type limited_weight: int
+        :type weight_per_axle: int
 
         :param height: Truck routing only, vehicle height in meters.
             The provided value must be between 0 and 50.
         :type height: int
 
         :param width: Truck routing only, vehicle width in meters.
             The provided value must be between 0 and 50.
@@ -813,43 +814,43 @@
             duration = int(response["response"]["route"][0]["summary"].get("baseTime"))
             distance = int(response["response"]["route"][0]["summary"].get("distance"))
 
             return Direction(geometry=geometry, duration=duration, distance=distance, raw=response)
 
     def isochrones(  # noqa: C901
         self,
-        locations,
-        profile,
-        intervals,
-        mode_type="fastest",
-        interval_type="time",
-        format="json",
-        center_type="start",
-        request_id=None,
-        arrival=None,
-        departure=None,
-        single_component=None,
-        resolution=None,
-        max_points=None,
-        quality=None,
-        json_attributes=None,
+        locations: List[float],
+        profile: str,
+        intervals: List[int],
+        mode_type: Optional[str] = "fastest",
+        interval_type: Optional[str] = "time",
+        format: Optional[str] = "json",
+        center_type: Optional[str] = "start",
+        request_id: Optional[str] = None,
+        arrival: Optional[str] = None,
+        departure: Optional[str] = None,
+        single_component: Optional[bool] = None,
+        resolution: Optional[int] = None,
+        max_points: Optional[int] = None,
+        quality: Optional[int] = None,
+        json_attributes: Optional[int] = None,
         json_callback=None,
-        truck_type=None,
-        trailers_count=None,
-        shipped_hazardous_goods=None,
-        limited_weight=None,
-        weight_per_axle=None,
-        height=None,
-        width=None,
-        length=None,
-        tunnel_category=None,
-        consumption_model=None,
-        custom_consumption_details=None,
-        speed_profile=None,
-        dry_run=None,
+        truck_type: Optional[str] = None,
+        trailers_count: Optional[int] = None,
+        shipped_hazardous_goods: Optional[List[str]] = None,
+        limited_weight: Optional[int] = None,
+        weight_per_axle: Optional[int] = None,
+        height: Optional[int] = None,
+        width: Optional[int] = None,
+        length: Optional[int] = None,
+        tunnel_category: Optional[List[str]] = None,
+        consumption_model: Optional[str] = None,
+        custom_consumption_details: Optional[str] = None,
+        speed_profile: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **isochrones_kwargs
     ):
         """Gets isochrones or equidistants for a range of time/distance values around a given set of coordinates.
 
         Use ``isochrones_kwargs`` for any missing ``isochrones`` request options.
 
         For more information, https://developer.here.com/documentation/routing/topics/resource-calculate-isoline.html.
@@ -860,24 +861,24 @@
         :param profile: Specifies the routing mode of transport and further options.
             Can be a str or :class:`HereMaps.RoutingMode`
             https://developer.here.com/documentation/routing/topics/resource-param-type-routing-mode.html
         :type profile: str or :class:`HereMaps.RoutingMode`
 
         :param intervals: Range of isoline. Several comma separated values can be specified.
             The unit is defined by parameter rangetype.
-        :type ranges: list of int
+        :type intervals: list of int
 
         :param mode_type: RoutingType relevant to calculation. One of [fastest, shortest, balanced]. Default fastest.
             https://developer.here.com/documentation/routing/topics/resource-param-type-routing-mode.html#ariaid-title2
         :type mode_type: str
 
         :param interval_type: Specifies type of range. Possible values are distance,
             time, consumption. For distance the unit is meters. For time the unit is seconds.
-            For consumption it is defined by consumption model
-        :type range_type: str
+            For consumption, it is defined by consumption model
+        :type interval_type: str
 
         :param format: Currently only "json" supported.
         :type format: str
 
         :param center_type: If 'start' then the isoline will cover all roads which
             can be reached from this point within given range.
             It cannot be used in combination with destination parameter.
@@ -919,15 +920,15 @@
             so it is possible that more points than maxpoints value will be returned.
             This is in case when 2 * number of components is higher than maxpoints.
             Enlarging number of maxpoints may cause increased response time from the service.
         :type max_points: int
 
         :param quality: Allows to reduce the quality of the isoline in favor
             of the response time. Allowed values are 1, 2, 3.
-            Default value is 1 and it is the best quality.
+            Default value is 1, and it is the best quality.
         :type quality: int
 
         :param json_attributes: Flag to control JSON output.
             Combine parameters by adding their values.
             https://developer.here.com/documentation/routing/topics/resource-param-type-json-representation.html
         :type json_attributes: int
 
@@ -947,15 +948,15 @@
 
         :param limited_weight: Truck routing only, vehicle weight including
             trailers and shipped goods, in tons. The provided value must be between 0 and 1000.
         :type limited_weight: int
 
         :param weight_per_axle: Truck routing only, vehicle weight per axle in tons.
             The provided value must be between 0 and 1000.
-        :type limited_weight: int
+        :type weight_per_axle: int
 
         :param height: Truck routing only, vehicle height in meters.
             The provided value must be between 0 and 50.
         :type height: int
 
         :param width: Truck routing only, vehicle width in meters.
             The provided value must be between 0 and 50.
@@ -1110,39 +1111,39 @@
                 )
             )
 
         return Isochrones(isochrones=geometries, raw=response)
 
     def matrix(  # noqa: C901
         self,
-        locations,
-        profile,
-        format="json",
-        mode_type="fastest",
-        sources=None,
-        destinations=None,
-        search_range=None,
-        avoid_areas=None,
-        avoid_links=None,
-        avoid_turns=None,
-        exclude_countries=None,
-        departure=None,
-        matrix_attributes=None,
-        summary_attributes=["traveltime", "costfactor", "distance"],
-        truck_type=None,
-        trailers_count=None,
-        shipped_hazardous_goods=None,
-        limited_weight=None,
-        weight_per_axle=None,
-        height=None,
-        width=None,
-        length=None,
-        tunnel_category=None,
-        speed_profile=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        format: Optional[str] = "json",
+        mode_type: Optional[str] = "fastest",
+        sources: Optional[List[int]] = None,
+        destinations: Optional[List[int]] = None,
+        search_range: Optional[int] = None,
+        avoid_areas: Optional[List[List[List[float]]]] = None,
+        avoid_links: Optional[List[str]] = None,
+        avoid_turns: Optional[str] = None,
+        exclude_countries: Optional[List[str]] = None,
+        departure: Optional[str] = None,
+        matrix_attributes: Optional[List[str]] = None,
+        summary_attributes: Optional[List[str]] = ["traveltime", "costfactor", "distance"],
+        truck_type: Optional[str] = None,
+        trailers_count: Optional[int] = None,
+        shipped_hazardous_goods: Optional[List[str]] = None,
+        limited_weight: Optional[int] = None,
+        weight_per_axle: Optional[int] = None,
+        height: Optional[int] = None,
+        width: Optional[int] = None,
+        length: Optional[int] = None,
+        tunnel_category: Optional[List[str]] = None,
+        speed_profile: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **matrix_kwargs
     ):
         """Gets travel distance and time for a matrix of origins and destinations.
 
         Use ``matrix_kwargs`` for any missing ``matrix`` request options.
 
         :param locations: The coordinates tuple the route should be calculated
@@ -1180,15 +1181,15 @@
         :param avoid_areas: Areas which the route must not cross.
             Array of BoundingBox. Example with 2 bounding boxes
             https://developer.here.com/documentation/routing/topics/resource-param-type-bounding-box.html
         :type avoid_areas: list of list of list
 
         :param avoid_links: Links which the route must not cross.
           The list of LinkIdTypes.
-        :type avoid_areas: list of string
+        :type avoid_links: list of string
 
         :param avoid_turns: List of turn types that the route should avoid. Defaults to empty list.
           https://developer.here.com/documentation/routing/topics/resource-type-enumerations.html
         :type avoid_turns: str
 
         :param exclude_countries: Countries that must be excluded from route calculation.
         :type exclude_countries: list of str
@@ -1209,15 +1210,15 @@
           https://developer.here.com/documentation/routing/topics/resource-calculate-matrix.html#resource-calculate-matrix__matrix-route-attribute-type
         :type matrix_attributes: list of str
 
         :param summary_attributes: Defines which attributes are included in
             the response as part of the data representation of the matrix
             entries summaries. Defaults to costfactor.
             https://developer.here.com/documentation/routing/topics/resource-calculate-matrix.html#resource-calculate-matrix__matrix-route-summary-attribute-type
-        :type matrix_attributes: list of str
+        :type summary_attributes: list of str
 
         :param truck_type: Truck routing only, specifies the vehicle type.
             Defaults to truck.
         :type truck_type: str
 
         :param trailers_count: Truck routing only, specifies number of
             trailers pulled by a vehicle. The provided value must be between 0 and 4.
@@ -1234,15 +1235,15 @@
         :param limited_weight: Truck routing only, vehicle weight including
             trailers and shipped goods, in tons. The provided value must be
             between 0 and 1000.
         :type limited_weight: int
 
         :param weight_per_axle: Truck routing only, vehicle weight per axle
             in tons. The provided value must be between 0 and 1000.
-        :type limited_weight: int
+        :type weight_per_axle: int
 
         :param height: Truck routing only, vehicle height in meters. The
             provided value must be between 0 and 50.
         :type height: int
 
         :param width: Truck routing only, vehicle width in meters.
             The provided value must be between 0 and 50.
```

## routingpy/routers/mapbox_osrm.py

```diff
@@ -13,14 +13,15 @@
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 """
 Core client functionality, common across all API requests.
 """
+from typing import List, Optional, Tuple, Union
 
 from .. import convert, utils
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..isochrone import Isochrone, Isochrones
 from ..matrix import Matrix
@@ -29,20 +30,20 @@
 class MapboxOSRM:
     """Performs requests to the OSRM API services."""
 
     _base_url = "https://api.mapbox.com"
 
     def __init__(
         self,
-        api_key,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
+        api_key: str,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
         client=Client,
         **client_kwargs
     ):
         """
         Initializes a Mapbox OSRM client.
 
         :param api_key: Mapbox API key.
@@ -90,34 +91,34 @@
             retry_over_query_limit,
             skip_api_error,
             **client_kwargs
         )
 
     def directions(  # noqa: C901
         self,
-        locations,
-        profile,
-        radiuses=None,
-        bearings=None,
-        alternatives=None,
-        steps=None,
-        continue_straight=None,
-        annotations=None,
-        geometries=None,
-        overview=None,
-        exclude=None,
-        approaches=None,
-        banner_instructions=None,
-        language=None,
-        roundabout_exits=None,
-        voice_instructions=None,
-        voice_units=None,
-        waypoint_names=None,
-        waypoint_targets=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        radiuses: Optional[Union[List[float], Tuple[float]]] = None,
+        bearings: Optional[List[List[int]]] = None,
+        alternatives: Optional[bool] = None,
+        steps: Optional[bool] = None,
+        continue_straight: Optional[bool] = None,
+        annotations: Optional[List[str]] = None,
+        geometries: Optional[str] = None,
+        overview: Optional[str] = None,
+        exclude: Optional[str] = None,
+        approaches: Optional[List[str]] = None,
+        banner_instructions: Optional[bool] = None,
+        language: Optional[str] = None,
+        roundabout_exits: Optional[bool] = None,
+        voice_instructions: Optional[bool] = None,
+        voice_units: Optional[str] = None,
+        waypoint_names: Optional[List[str]] = None,
+        waypoint_targets: Optional[List[List[float]]] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Get directions between an origin point and a destination point.
 
         For more information, visit https://docs.mapbox.com/api/navigation/#directions.
 
         :param locations: The coordinates tuple the route should be calculated
             from in order of visit.
@@ -338,22 +339,22 @@
                 duration=int(response["routes"][0]["duration"]),
                 distance=int(response["routes"][0]["distance"]),
                 raw=response,
             )
 
     def isochrones(
         self,
-        locations,
-        profile,
-        intervals,
-        contours_colors=None,
-        polygons=None,
-        denoise=None,
-        generalize=None,
-        dry_run=None,
+        locations: List[float],
+        profile: str,
+        intervals: List[int],
+        contours_colors: Optional[List[str]] = None,
+        polygons: Optional[bool] = None,
+        denoise: Optional[float] = None,
+        generalize: Optional[float] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Gets isochrones or equidistants for a range of time values around a given set of coordinates.
 
         For more information, visit https://github.com/valhalla/valhalla/blob/master/docs/api/isochrone/api-reference.md.
 
         :param locations: One pair of lng/lat values. Takes the form [Longitude, Latitude].
         :type locations: list of float
@@ -433,21 +434,21 @@
                 for idx, isochrone in enumerate(list(reversed(response["features"])))
             ],
             response,
         )
 
     def matrix(
         self,
-        locations,
-        profile,
-        sources=None,
-        destinations=None,
-        annotations=None,
-        fallback_speed=None,
-        dry_run=None,
+        locations: Union[List[float], Tuple[float]],
+        profile: str,
+        sources: Optional[Union[List[int], Tuple[int]]] = None,
+        destinations: Optional[Union[List[int], Tuple[int]]] = None,
+        annotations: Optional[List[str]] = None,
+        fallback_speed: Optional[int] = None,
+        dry_run: Optional[bool] = None,
     ):
         """
         Gets travel distance and time for a matrix of origins and destinations.
 
         For more information visit https://docs.mapbox.com/api/navigation/#matrix.
 
         :param locations: The coordinates tuple the route should be calculated
```

## routingpy/routers/openrouteservice.py

```diff
@@ -10,14 +10,15 @@
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
+from typing import List, Optional
 
 from .. import utils
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..isochrone import Isochrone, Isochrones
 from ..matrix import Matrix
@@ -26,21 +27,21 @@
 class ORS:
     """Performs requests to the ORS API services."""
 
     _DEFAULT_BASE_URL = "https://api.openrouteservice.org"
 
     def __init__(
         self,
-        api_key=None,
-        base_url=_DEFAULT_BASE_URL,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
+        api_key: Optional[str] = None,
+        base_url: Optional[str] = _DEFAULT_BASE_URL,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
         client=Client,
         **client_kwargs
     ):
         """
         Initializes an openrouteservice client.
 
         :param api_key: ORS API key. Required if https://api.openrouteservice.org is used.
@@ -96,36 +97,36 @@
             retry_over_query_limit,
             skip_api_error,
             **client_kwargs
         )
 
     def directions(  # noqa: C901
         self,
-        locations,
-        profile,
-        format="geojson",
-        preference=None,
-        alternative_routes=None,
-        units=None,
-        language=None,
-        geometry=None,
-        geometry_simplify=None,
-        instructions=None,
-        instructions_format=None,
-        roundabout_exits=None,
-        attributes=None,
-        radiuses=None,
-        maneuvers=None,
-        bearings=None,
-        continue_straight=None,
-        elevation=None,
-        extra_info=None,
-        suppress_warnings=None,
-        options=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        format: Optional[str] = "geojson",
+        preference: Optional[str] = None,
+        alternative_routes: Optional[dict] = None,
+        units: Optional[str] = None,
+        language: Optional[str] = None,
+        geometry: Optional[bool] = None,
+        geometry_simplify: Optional[bool] = None,
+        instructions: Optional[bool] = None,
+        instructions_format: Optional[str] = None,
+        roundabout_exits: Optional[bool] = None,
+        attributes: Optional[List[str]] = None,
+        radiuses: Optional[List[int]] = None,
+        maneuvers: Optional[bool] = None,
+        bearings: Optional[List[List[float]]] = None,
+        continue_straight: Optional[bool] = None,
+        elevation: Optional[bool] = None,
+        extra_info: Optional[List[str]] = None,
+        suppress_warnings: Optional[bool] = None,
+        options: Optional[dict] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Get directions between an origin point and a destination point.
 
         For more information, visit https://openrouteservice.org/dev/#/api-docs/v2/directions/{profile}/post
 
         :param locations: The coordinates tuple the route should be calculated
             from in order of visit.
@@ -203,15 +204,15 @@
             work for all profiles. The number of bearings corresponds to the length
             of waypoints-1 or waypoints. If the bearing information for the last waypoint
             is given, then this will control the sector from which the destination
             waypoint may be reached.
         :type bearings: list of list
 
         :param continue_straight: Forces the route to keep going straight at waypoints not
-            restricting u-turns even if u-turns would be faster. Default False.
+            restricting U-turns even if U-turns would be faster. Default False.
         :type continue_straight: bool
 
         :param elevation: Specifies whether to return elevation values for points.
             Default False.
         :type elevation: bool
 
         :param extra_info: Returns additional information on ["steepness", "suitability",
@@ -370,24 +371,24 @@
                 duration = int(response["routes"][0]["summary"]["duration"])
                 distance = int(response["routes"][0]["summary"]["distance"] * units_factor)
 
                 return Direction(geometry=geometry, duration=duration, distance=distance, raw=response)
 
     def isochrones(
         self,
-        locations,
-        profile,
-        intervals,
-        interval_type="time",
-        units=None,
-        location_type=None,
-        smoothing=None,
-        attributes=None,
-        intersections=None,
-        dry_run=None,
+        locations: List[float],
+        profile: str,
+        intervals: List[int],
+        interval_type: Optional[str] = "time",
+        units: Optional[str] = None,
+        location_type: Optional[str] = "start",
+        smoothing: Optional[float] = None,
+        attributes: Optional[List[str]] = None,
+        intersections: Optional[bool] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Gets isochrones or equidistants for a range of time/distance values around a given set of coordinates.
 
         :param locations: One pair of lng/lat values.
         :type locations: list of float
 
         :param profile: Specifies the mode of transport to use when calculating
@@ -481,22 +482,22 @@
                 )
             )
 
         return Isochrones(isochrones=isochrones, raw=response)
 
     def matrix(
         self,
-        locations,
-        profile,
-        sources=None,
-        destinations=None,
-        metrics=None,
-        resolve_locations=None,
-        units=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        sources: Optional[List[int]] = None,
+        destinations: Optional[List[int]] = None,
+        metrics: Optional[List[str]] = None,
+        resolve_locations: Optional[bool] = None,
+        units: Optional[str] = None,
+        dry_run: Optional[bool] = None,
     ):
         """Gets travel distance and time for a matrix of origins and destinations.
 
         :param locations: Two or more pairs of lng/lat values.
         :type locations: list of list
 
         :param profile: Specifies the mode of transport to use when calculating
```

## routingpy/routers/osrm.py

```diff
@@ -11,15 +11,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 #
 
-from typing import List  # noqa: F401
+from typing import List, Optional, Union  # noqa: F401
 
 from .. import convert, utils
 from ..client_base import DEFAULT
 from ..client_default import Client
 from ..direction import Direction, Directions
 from ..matrix import Matrix
 
@@ -27,20 +27,20 @@
 class OSRM:
     """Performs requests to the OSRM API services."""
 
     _DEFAULT_BASE_URL = "https://routing.openstreetmap.de/routed-bike"
 
     def __init__(
         self,
-        base_url=_DEFAULT_BASE_URL,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
+        base_url: Optional[str] = _DEFAULT_BASE_URL,
+        user_agent: Optional[str] = None,
+        timeout: Optional[int] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
         client=Client,
         **client_kwargs,
     ):
         """
         Initializes an OSRM client.
 
         :param base_url: The base URL for the request. Defaults to the FOSSGIS OSRM
@@ -85,25 +85,25 @@
             retry_over_query_limit,
             skip_api_error,
             **client_kwargs,
         )
 
     def directions(
         self,
-        locations,
-        profile="driving",
-        radiuses=None,
-        bearings=None,
-        alternatives=None,
-        steps=None,
-        continue_straight=None,
-        annotations=None,
-        geometries=None,
-        overview=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: Optional[str] = "driving",
+        radiuses: Optional[List[int]] = None,
+        bearings: Optional[List[List[float]]] = None,
+        alternatives: Optional[Union[bool, int]] = None,
+        steps: Optional[bool] = None,
+        continue_straight: Optional[bool] = None,
+        annotations: Optional[bool] = None,
+        geometries: Optional[str] = None,
+        overview: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **direction_kwargs,
     ):
         """
         Get directions between an origin point and a destination point.
 
         Use ``direction_kwargs`` for any missing ``directions`` request options.
 
@@ -143,25 +143,25 @@
             Default False.
         :type alternatives: bool or int
 
         :param steps: Return route steps for each route leg. Default false.
         :type steps: bool
 
         :param continue_straight: Forces the route to keep going straight at waypoints constraining
-            uturns there even if it would be faster. Default value depends on the profile.
+            U-turns there even if it would be faster. Default value depends on the profile.
         :type continue_straight: bool
 
         :param annotations: Returns additional metadata for each coordinate along the route geometry. Default false.
         :type annotations: bool
 
         :param geometries: Returned route geometry format (influences overview and per step). One of ["polyline",
             "polyline6", "geojson". Default polyline.
         :type geometries: str
 
-        :param overview: Add overview geometry either full, simplified according to highest zoom level
+        :param overview: Add overview geometry either full, simplified according to the highest zoom level
             it could be display on, or not at all. One of ["simplified", "full", "false", False]. Default simplified.
         :type overview: str
 
         :param dry_run: Print URL and parameters without sending the request.
         :param dry_run: bool
 
         :returns: One or multiple route(s) from provided coordinates and restrictions.
@@ -286,22 +286,22 @@
             )
 
     def isochrones(self):  # pragma: no cover
         raise NotImplementedError
 
     def matrix(
         self,
-        locations,
-        profile="driving",
-        radiuses=None,
-        bearings=None,
-        sources=None,
-        destinations=None,
-        dry_run=None,
-        annotations=("duration", "distance"),
+        locations: List[List[float]],
+        profile: Optional[str] = "driving",
+        radiuses: Optional[List[int]] = None,
+        bearings: Optional[List[List[float]]] = None,
+        sources: Optional[List[int]] = None,
+        destinations: Optional[List[int]] = None,
+        dry_run: Optional[bool] = None,
+        annotations: Optional[List[str]] = ("duration", "distance"),
         **matrix_kwargs,
     ):
         """
         Gets travel distance and time for a matrix of origins and destinations.
 
         Use ``matrix_kwargs`` for any missing ``matrix`` request options.
```

## routingpy/routers/valhalla.py

```diff
@@ -27,68 +27,57 @@
 from ..matrix import Matrix
 from ..valhalla_attributes import MatchedResults
 
 
 class Valhalla:
     """Performs requests to a Valhalla instance."""
 
+    _DEFAULT_BASE_URL = "https://valhalla1.openstreetmap.de"
+
     def __init__(
         self,
-        base_url,
-        api_key=None,
-        user_agent=None,
-        timeout=DEFAULT,
-        retry_timeout=None,
-        retry_over_query_limit=False,
-        skip_api_error=None,
+        base_url: str = _DEFAULT_BASE_URL,
+        user_agent: Optional[str] = None,
+        timeout: Optional[Union[int, None]] = DEFAULT,
+        retry_timeout: Optional[int] = None,
+        retry_over_query_limit: Optional[bool] = False,
+        skip_api_error: Optional[bool] = None,
         client=Client,
-        **client_kwargs
+        **client_kwargs: dict
     ):
         """
         Initializes a Valhalla client.
 
-        :param api_key: Mapbox API key. Required if base_url='https://api.mapbox.com/valhalla/v1'.
-        :type api_key: str
-
-        :param base_url: The base URL for the request. Defaults to the ORS API
+        :param base_url: The base URL for the request. Defaults to the public OSM
             server. Should not have a trailing slash.
-        :type base_url: str
 
         :param user_agent: User Agent to be used when requesting.
             Default :attr:`routingpy.routers.options.default_user_agent`.
-        :type user_agent: str
 
         :param timeout: Combined connect and read timeout for HTTP requests, in
             seconds. Specify ``None`` for no timeout. Default :attr:`routingpy.routers.options.default_timeout`.
-        :type timeout: int or None
 
         :param retry_timeout: Timeout across multiple retriable requests, in
             seconds.  Default :attr:`routingpy.routers.options.default_retry_timeout`.
-        :type retry_timeout: int
 
         :param retry_over_query_limit: If True, client will not raise an exception
             on HTTP 429, but instead jitter a sleeping timer to pause between
             requests until HTTP 200 or retry_timeout is reached.
             Default :attr:`routingpy.routers.options.default_retry_over_query_limit`.
-        :type retry_over_query_limit: bool
 
         :param skip_api_error: Continue with batch processing if a :class:`routingpy.exceptions.RouterApiError` is
             encountered (e.g. no route found). If False, processing will discontinue and raise an error.
             Default :attr:`routingpy.routers.options.default_skip_api_error`.
-        :type skip_api_error: bool
 
         :param client: A client class for request handling. Needs to be derived from :class:`routingpy.base.BaseClient`
         :type client: abc.ABCMeta
 
         :param client_kwargs: Additional arguments passed to the client, such as headers or proxies.
-        :type client_kwargs: dict
         """
 
-        self.api_key = api_key
-
         self.client = client(
             base_url,
             user_agent,
             timeout,
             retry_timeout,
             retry_over_query_limit,
             skip_api_error,
@@ -118,80 +107,80 @@
             for k, v in self._kwargs.items():
                 waypoint[k] = v
 
             return waypoint
 
     def directions(
         self,
-        locations,
-        profile,
-        preference=None,
-        options=None,
-        units=None,
-        instructions=False,
-        language=None,
-        directions_type=None,
-        avoid_locations=None,
-        avoid_polygons=None,
-        date_time=None,
-        id=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        preference: Optional[str] = None,
+        options: Optional[dict] = None,
+        units: Optional[str] = None,
+        instructions: Optional[bool] = False,
+        language: Optional[str] = None,
+        directions_type: Optional[str] = None,
+        avoid_locations: Optional[List[List[float]]] = None,
+        avoid_polygons: Optional[List[List[List[float]]]] = None,
+        date_time: Optional[dict] = None,
+        id: Optional[Union[str, int, float]] = None,
+        dry_run: Optional[bool] = None,
         **kwargs
     ):
         """Get directions between an origin point and a destination point.
 
         For more information, visit https://github.com/valhalla/valhalla/blob/master/docs/api/turn-by-turn/api-reference.md.
 
         Use ``kwargs`` for any missing ``directions`` request options.
 
-        :param Union[List[List[float]]|List[Valhalla.Waypoint]] locations: The coordinates tuple the route should be calculated
+        :param locations: The coordinates tuple the route should be calculated
             from in order of visit. Can be a list/tuple of [lon, lat] or :class:`Valhalla.WayPoint` instance or
             a combination of both.
 
-        :param str profile: Specifies the mode of transport to use when calculating
+        :param profile: Specifies the mode of transport to use when calculating
             directions. One of ["auto", "auto_shorter" (deprecated), "bicycle", "bus", "hov", "motor_scooter",
-            "motorcycle", "multimodal", "pedestrian".
+            "motorcycle", "multimodal", "pedestrian"].
 
-        :param str preference: Convenience argument to set the cost metric, one of ['shortest', 'fastest']. Note,
+        :param preference: Convenience argument to set the cost metric, one of ['shortest', 'fastest']. Note,
             that shortest is not guaranteed to be absolute shortest for motor vehicle profiles. It's called ``preference``
             to be inline with the already existing parameter in the ORS adapter.
 
-        :param dict options: Profiles can have several options that can be adjusted to develop the route path,
+        :param options: Profiles can have several options that can be adjusted to develop the route path,
             as well as for estimating time along the path. Only specify the actual options dict, the profile
             will be filled automatically. For more information, visit:
             https://github.com/valhalla/valhalla/blob/master/docs/api/turn-by-turn/api-reference.md#costing-options
 
-        :param str units: Distance units for output. One of ['mi', 'km']. Default km.
+        :param units: Distance units for output. One of ['mi', 'km']. Default km.
 
-        :param bool instructions: Whether to return turn-by-turn instructions. Named for compatibility with other
+        :param instructions: Whether to return turn-by-turn instructions. Named for compatibility with other
             providers. Valhalla's parameter here is 'narrative'.
 
-        :param str language: The language of the narration instructions based on the IETF BCP 47 language tag string.
+        :param language: The language of the narration instructions based on the IETF BCP 47 language tag string.
             One of ['ca', 'cs', 'de', 'en', 'pirate', 'es', 'fr', 'hi', 'it', 'pt', 'ru', 'sl', 'sv']. Default 'en'.
 
-        :param str directions_type: 'none': no instructions are returned. 'maneuvers': only maneuvers are returned.
+        :param directions_type: 'none': no instructions are returned. 'maneuvers': only maneuvers are returned.
             'instructions': maneuvers with instructions are returned. Default 'instructions'.
 
-        :param Union[List[List[float]]|List[Valhalla.Waypoint]] avoid_locations: A set of locations to exclude or avoid within a route.
+        :param avoid_locations: A set of locations to exclude or avoid within a route.
             Specified as a list of coordinates, similar to coordinates object.
 
-        :param List[List[List[float]]] avoid_polygons: One or multiple exterior rings of polygons in the form of nested
+        :param avoid_polygons: One or multiple exterior rings of polygons in the form of nested
             JSON arrays, e.g. [[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]]. Roads intersecting these rings
             will be avoided during path finding. If you only need to avoid a few specific roads, it's much more
             efficient to use avoid_locations. Valhalla will close open rings (i.e. copy the first coordingate to the
             last position).
 
-        :param dict date_time: This is the local date and time at the location. Field ``type``: 0: Current departure time,
+        :param date_time: This is the local date and time at the location. Field ``type``: 0: Current departure time,
             1: Specified departure time. Field ``value```: the date and time is specified
             in ISO 8601 format (YYYY-MM-DDThh:mm), local time.
             E.g. date_time = {type: 0, value: 2021-03-03T08:06:23}
 
-        :param Union[str|int|float] id: Name your route request. If id is specified, the naming will be sent thru to the response.
+        :param id: Name your route request. If id is specified, the naming will be sent thru to the response.
 
-        :param bool dry_run: Print URL and parameters without sending the request.
+        :param dry_run: Print URL and parameters without sending the request.
 
         :param kwargs: any additional keyword arguments which will override parameters.
 
         :returns: A route from provided coordinates and restrictions.
         :rtype: :class:`routingpy.direction.Direction`
         """
 
@@ -207,18 +196,16 @@
             avoid_locations,
             avoid_polygons,
             date_time,
             id,
             **kwargs
         )
 
-        get_params = {"access_token": self.api_key} if self.api_key else {}
-
         return self.parse_direction_json(
-            self.client._request("/route", get_params=get_params, post_params=params, dry_run=dry_run),
+            self.client._request("/route", post_params=params, dry_run=dry_run),
             units,
         )
 
     @staticmethod
     def get_direction_params(
         locations,
         profile,
@@ -290,110 +277,95 @@
             factor = 0.621371 if units == "mi" else 1
             distance += int(leg["summary"]["length"] * 1000 * factor)
 
         return Direction(geometry=geometry, duration=int(duration), distance=int(distance), raw=response)
 
     def isochrones(  # noqa: C901
         self,
-        locations,
-        profile,
-        intervals,
-        interval_type="time",
-        colors=None,
-        polygons=None,
-        denoise=None,
-        generalize=None,
-        preference=None,
-        options=None,
-        units=None,
-        language=None,
-        directions_type=None,
-        avoid_locations=None,
-        avoid_polygons=None,
-        date_time=None,
-        show_locations=None,
-        id=None,
-        dry_run=None,
+        locations: List[float],
+        profile: str,
+        intervals: List[int],
+        interval_type: Optional[str] = "time",
+        colors: Optional[List[str]] = None,
+        polygons: Optional[bool] = None,
+        denoise: Optional[float] = None,
+        generalize: Optional[float] = None,
+        preference: Optional[str] = None,
+        options: Optional[dict] = None,
+        units: Optional[str] = None,
+        language: Optional[str] = None,
+        directions_type: Optional[str] = None,
+        avoid_locations: Optional[List[List[float]]] = None,
+        avoid_polygons: Optional[List[List[List[float]]]] = None,
+        date_time: Optional[dict] = None,
+        show_locations: Optional[List[List[float]]] = None,
+        id: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **kwargs
     ):
         """Gets isochrones or equidistants for a range of time values around a given set of coordinates.
 
         For more information, visit https://github.com/valhalla/valhalla/blob/master/docs/api/isochrone/api-reference.md.
 
         Use ``kwargs`` for any missing ``isochrones`` request options.
 
         :param locations: One pair of lng/lat values. Takes the form [Longitude, Latitude].
-        :type locations: list of float
 
         :param profile: Specifies the mode of transport to use when calculating
             directions. One of ["auto", "bicycle", "multimodal", "pedestrian".
-        :type profile: str
 
         :param intervals: Time ranges to calculate isochrones for. In seconds or meters, depending on `interval_type`.
-        :type intervals: list of int
 
         :param interval_type: Set 'time' for isochrones or 'distance' for equidistants.
             Default 'time'.
-        :type interval_type: str
 
         :param colors: The color for the output of the contour. Specify it as a Hex value, but without the #, such as
             "color":"ff0000" for red. If no color is specified, the isochrone service will assign a default color to the output.
-        :type colors: list of str
 
         :param polygons: Controls whether polygons or linestrings are returned in GeoJSON geometry. Default False.
-        :type polygons: bool
 
         :param denoise: Can be used to remove smaller contours. In range [0, 1]. A value of 1 will only return the largest contour
             for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest
             contour in the set of contours for that same time value. Default 1.
-        :type denoise: float
 
         :param generalize: A floating point value in meters used as the tolerance for Douglas-Peucker generalization.
             Note: Generalization of contours can lead to self-intersections, as well as intersections of adjacent contours.
-        :type generalize: float
 
-        :param str preference: Convenience argument to set the cost metric, one of ['shortest', 'fastest']. Note,
+        :param preference: Convenience argument to set the cost metric, one of ['shortest', 'fastest']. Note,
             that shortest is not guaranteed to be absolute shortest for motor vehicle profiles. It's called ``preference``
             to be inline with the already existing parameter in the ORS adapter.
 
         :param options: Profiles can have several options that can be adjusted to develop the route path,
             as well as for estimating time along the path. Only specify the actual options dict, the profile
             will be filled automatically. For more information, visit:
             https://github.com/valhalla/valhalla/blob/master/docs/api/turn-by-turn/api-reference.md#costing-options
-        :type options: dict
 
         :param units: Distance units for output. One of ['mi', 'km']. Default km.
-        :type units: str
 
         :param language: The language of the narration instructions based on the IETF BCP 47 language tag string.
             One of ['ca', 'cs', 'de', 'en', 'pirate', 'es', 'fr', 'hi', 'it', 'pt', 'ru', 'sl', 'sv']. Default 'en'.
-        :type language: str
 
         :param avoid_locations: A set of locations to exclude or avoid within a route.
             Specified as a list of coordinates, similar to coordinates object.
-        :type avoid_locations: list of list
 
         :param List[List[List[float]]] avoid_polygons: One or multiple exterior rings of polygons in the form of nested
             JSON arrays, e.g. [[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]]. Roads intersecting these rings
             will be avoided during path finding. If you only need to avoid a few specific roads, it's much more
             efficient to use avoid_locations. Valhalla will close open rings (i.e. copy the first coordingate to the
             last position).
 
         :param date_time: This is the local date and time at the location. Field ``type``: 0: Current departure time,
             1: Specified departure time. Field ``value```: the date and time is specified
             in format YYYY-MM-DDThh:mm, local time.
 
             E.g. date_time = {type: 0, value: 2021-03-03T08:06}
-        :type date_time: dict
 
         :param id: Name your route request. If id is specified, the naming will be sent thru to the response.
-        :type id: str
 
         :param dry_run: Print URL and parameters without sending the request.
-        :param dry_run: bool
 
         :returns: An isochrone with the specified range.
         :rtype: :class:`routingpy.isochrone.Isochrones`
         """
 
         params = self.get_isochrone_params(
             locations,
@@ -410,30 +382,27 @@
             avoid_polygons,
             date_time,
             show_locations,
             id,
             **kwargs
         )
 
-        get_params = {"access_token": self.api_key} if self.api_key else {}
         return self.parse_isochrone_json(
-            self.client._request(
-                "/isochrone", get_params=get_params, post_params=params, dry_run=dry_run
-            ),
+            self.client._request("/isochrone", post_params=params, dry_run=dry_run),
             intervals,
             locations,
             interval_type,
         )
 
     @staticmethod  # noqa: C901
     def get_isochrone_params(  # noqa: C901
         locations,
         profile,
         intervals,
-        interval_type="time",
+        interval_type,
         colors=None,
         polygons=None,
         denoise=None,
         generalize=None,
         preference=None,
         options=None,
         avoid_locations=None,
@@ -523,77 +492,73 @@
                     )
                 )
 
         return Isochrones(isochrones, response)
 
     def matrix(
         self,
-        locations,
-        profile,
-        sources=None,
-        destinations=None,
-        preference=None,
-        options=None,
-        avoid_locations=None,
-        avoid_polygons=None,
-        units=None,
-        id=None,
-        dry_run=None,
+        locations: List[List[float]],
+        profile: str,
+        sources: Optional[List[int]] = None,
+        destinations: Optional[List[int]] = None,
+        preference: Optional[str] = None,
+        options: Optional[dict] = None,
+        avoid_locations: Optional[List[List[float]]] = None,
+        avoid_polygons: Optional[List[List[List[float]]]] = None,
+        units: Optional[str] = None,
+        date_time: Optional[dict] = None,
+        id: Optional[str] = None,
+        dry_run: Optional[bool] = None,
         **kwargs
     ):
         """
         Gets travel distance and time for a matrix of origins and destinations.
 
         For more information, visit https://github.com/valhalla/valhalla/blob/master/docs/api/matrix/api-reference.md.
 
         Use ``kwargs`` for any missing ``matrix`` request options.
 
         :param locations: Multiple pairs of lng/lat values.
-        :type locations: list of list
 
         :param profile: Specifies the mode of transport to use when calculating
             matrices. One of ["auto", "bicycle", "multimodal", "pedestrian".
-        :type profile: str
 
         :param sources: A list of indices that refer to the list of locations
             (starting with 0). If not passed, all indices are considered.
-        :type sources: list of int
 
         :param destinations: A list of indices that refer to the list of locations
             (starting with 0). If not passed, all indices are considered.
-        :type destinations: list of int
 
         :param str preference: Convenience argument to set the cost metric, one of ['shortest', 'fastest']. Note,
             that shortest is not guaranteed to be absolute shortest for motor vehicle profiles. It's called ``preference``
             to be inline with the already existing parameter in the ORS adapter.
 
         :param options: Profiles can have several options that can be adjusted to develop the route path,
             as well as for estimating time along the path. Only specify the actual options dict, the profile
             will be filled automatically. For more information, visit:
             https://github.com/valhalla/valhalla/blob/master/docs/api/turn-by-turn/api-reference.md#costing-options
-        :type options: dict
 
         :param avoid_locations: A set of locations to exclude or avoid within a route.
             Specified as a list of coordinates, similar to coordinates object.
-        :type avoid_locations: list of list
 
         :param List[List[List[float]]] avoid_polygons: One or multiple exterior rings of polygons in the form of nested
             JSON arrays, e.g. [[[lon1, lat1], [lon2,lat2]],[[lon1,lat1],[lon2,lat2]]]. Roads intersecting these rings
             will be avoided during path finding. If you only need to avoid a few specific roads, it's much more
             efficient to use avoid_locations. Valhalla will close open rings (i.e. copy the first coordingate to the
             last position).
 
         :param units: Distance units for output. One of ['mi', 'km']. Default km.
-        :type units: str
+
+        :param date_time: This is the local date and time at the location. Field ``type``: 0: Current departure time,
+            1: Specified departure time. Field ``value```: the date and time is specified
+            in format YYYY-MM-DDThh:mm, local time.
 
         :param id: Name your route request. If id is specified, the naming will be sent through to the response.
-        :type id: str
 
         :param dry_run: Print URL and parameters without sending the request.
-        :param dry_run: bool
 
         :returns: A matrix from the specified sources and destinations.
         :rtype: :class:`routingpy.matrix.Matrix`
         """
 
         params = self.get_matrix_params(
             locations,
@@ -601,38 +566,36 @@
             sources,
             destinations,
             preference,
             options,
             avoid_locations,
             avoid_polygons,
             units,
+            date_time,
             id,
             **kwargs
         )
 
-        get_params = {"access_token": self.api_key} if self.api_key else {}
-
         return self.parse_matrix_json(
-            self.client._request(
-                "/sources_to_targets", get_params=get_params, post_params=params, dry_run=dry_run
-            ),
+            self.client._request("/sources_to_targets", post_params=params, dry_run=dry_run),
             units,
         )
 
     @staticmethod
     def get_matrix_params(
         locations,
         profile,
         sources=None,
         destinations=None,
         preference=None,
         options=None,
         avoid_locations=None,
         avoid_polygons=None,
         units=None,
+        date_time=None,
         id=None,
         **kwargs
     ):
         """
         Builds and returns the router's route parameters. It's a separate function so that
         bindings can use routingpy's functionality. See documentation of .matrix().
         """
@@ -670,14 +633,17 @@
 
         if avoid_polygons:
             params["avoid_polygons"] = avoid_polygons
 
         if units:
             params["units"] = units
 
+        if date_time:
+            params["date_time"] = date_time
+
         if id:
             params["id"] = id
 
         return params
 
     @staticmethod
     def parse_matrix_json(response, units):
@@ -745,32 +711,28 @@
 
         :param id: Name your route request. If id is specified, the naming will be sent thru to the response.
 
         :param dry_run: Print URL and parameters without sending the request.
 
         :returns: An expansions object consisting of single line strings and their attributes (if specified).
         """
-
-        get_params = {"access_token": self.api_key} if self.api_key else {}
         params = self.get_expansion_params(
             locations,
             profile,
             intervals,
             skip_opposites,
             expansion_properties,
             interval_type,
             options,
             date_time,
             id,
             **kwargs
         )
         return self.parse_expansion_json(
-            self.client._request(
-                "/expansion", get_params=get_params, post_params=params, dry_run=dry_run
-            ),
+            self.client._request("/expansion", post_params=params, dry_run=dry_run),
             locations,
             expansion_properties,
             interval_type,
         )
 
     @classmethod
     def get_expansion_params(
@@ -855,27 +817,23 @@
             will be filled automatically. For more information, visit:
             https://github.com/valhalla/valhalla/blob/master/docs/api/turn-by-turn/api-reference.md#costing-options
         :param dry_run: Print URL and parameters without sending the request.
 
         :raises: ValueError if 'locations' and 'encoded_polyline' was specified
         :returns: A :class:`MatchedResults` object with matched edges and points set.
         """
-
-        get_params = {"access_token": self.api_key} if self.api_key else {}
         if locations and encoded_polyline:
             raise ValueError
 
         params = self.get_trace_attributes_params(
             locations, profile, shape_match, encoded_polyline, filters, filters_action, options, **kwargs
         )
 
         return self.parse_trace_attributes_json(
-            self.client._request(
-                "/trace_attributes", get_params=get_params, post_params=params, dry_run=dry_run
-            )
+            self.client._request("/trace_attributes", post_params=params, dry_run=dry_run)
         )
 
     @classmethod
     def get_trace_attributes_params(
         cls,
         locations: Optional[Sequence[Union[Sequence[float], Waypoint]]] = None,
         profile: str = "bicycle",
```

## Comparing `routingpy-1.2.1.dist-info/LICENSE` & `routingpy-1.3.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `routingpy-1.2.1.dist-info/METADATA` & `routingpy-1.3.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 Metadata-Version: 2.1
 Name: routingpy
-Version: 1.2.1
+Version: 1.3.0
 Summary: One lib to route them all.
 Home-page: https://github.com/gis-ops/routing-py
 Author: Nils Nolde
 Author-email: nils@gis-ops.com
 License: Apache 2.0
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=3.7.0
+Requires-Python: >=3.8.0
 Description-Content-Type: text/x-rst
 License-File: LICENSE
 License-File: AUTHORS.md
 Requires-Dist: requests (>=2.20.0)
 
 
 routingpy
@@ -48,21 +47,22 @@
 **routingpy** currently includes support for the following services:
 
 -  `Mapbox, either Valhalla or OSRM`_
 -  `Openrouteservice`_
 -  `Here Maps`_
 -  `Google Maps`_
 -  `Graphhopper`_
+-  `OpenTripPlannerV2`_
 -  `Local Valhalla`_
 -  `Local OSRM`_
 
 This list is hopefully growing with time and contributions by other developers. An up-to-date list is always available
 in our documentation_.
 
-**routing-py** is tested against CPython versions 3.7, 3.8, 3.9, 3.10, 3.11. PyPy3 is currently not supported, see `#60 <https://github.com/gis-ops/routingpy/issues/60>`_.
+**routing-py** is tested against CPython versions 3.8, 3.9, 3.10, 3.11. PyPy3 is currently not supported, see `#60 <https://github.com/gis-ops/routingpy/issues/60>`_.
 
 Â© routingpy contributors 2022 under the `Apache 2.0 License`_.
 
 .. image:: https://user-images.githubusercontent.com/10322094/57357720-e180c080-7173-11e9-97a4-cecb4670065d.jpg
     :alt: routing-py-image
 
 
@@ -312,14 +312,15 @@
 
 
 .. _Mapbox, either Valhalla or OSRM: https://docs.mapbox.com/api/navigation
 .. _Openrouteservice: https://openrouteservice.org/dev/#/api-docs
 .. _Here Maps: https://developer.here.com/documentation
 .. _Google Maps: https://developers.google.com/maps/documentation
 .. _Graphhopper: https://graphhopper.com/api/1/docs
-.. _Local Valhalla: https://github.com/valhalla/valhalla-docs
+.. _OpenTripPlannerV2: https://docs.opentripplanner.org/en/latest/
+.. _Local Valhalla: https://valhalla.github.io/valhalla/
 .. _Local OSRM: https://github.com/Project-OSRM/osrm-backend/wiki
 .. _documentation: https://routingpy.readthedocs.io/en/latest
 .. _routing-py.routers: https://routingpy.readthedocs.io/en/latest/#module-routingpy.routers
 .. _Apache 2.0 License: https://github.com/gis-ops/routing-py/blob/master/LICENSE
 .. _mybinder.org: https://mybinder.org/v2/gh/gis-ops/routing-py/master?filepath=examples
 .. _poetry: https://github.com/sdispater/poetry
```

## Comparing `routingpy-1.2.1.dist-info/RECORD` & `routingpy-1.3.0.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,28 @@
-routingpy/__init__.py,sha256=lIWliNL5V9tCmgpPEn7SRAmogmY7b4hoIGGD8cE2-xI,1486
-routingpy/__version__.py,sha256=Mlm4Gvmb_6yQxwUbv2Ksc-BJFXLPg9H1Vt2iV7wXrA4,22
+routingpy/__init__.py,sha256=7a_Hs9Arp609YTQDlkQY6AL3X9BGX9bBaCe-MKf8jYc,1481
+routingpy/__version__.py,sha256=F5mW07pSyGrqDNY2Ehr-UpDzpBtN-FsYU0QGZWf6PJE,22
 routingpy/client_base.py,sha256=t3s2yWHVvLYIFh85ed8WeZgRrDwnH2nlHOLS8uN7n-Y,7857
-routingpy/client_default.py,sha256=virhvdQNIJVN2q4jn8XSP_pCf2_xGGKuO_-ZIXpU54s,8715
-routingpy/convert.py,sha256=qcjIwYzSCw8Ag63rXGetUo6h1iJt3mG89xPNaFYYFck,2230
-routingpy/direction.py,sha256=pfMMZABf_IGZfMNyf7ggtiCK8fRzKbMoBbXOKO4dQGE,3761
-routingpy/exceptions.py,sha256=WtpZuOnRW-hZQS_jEx_O-RRTSUSHvXY_zPDTFNkQgFU,2051
-routingpy/expansion.py,sha256=r_SIbpNk3mOYHqVo9wzuyQhg2DZ0eb9JXKuZVXnmm9M,4527
-routingpy/isochrone.py,sha256=JfnuxdeM3sGMKaO8UaeOveFk8fCSAy5zb5q0k-RZmow,3002
-routingpy/matrix.py,sha256=-XjAJ_FllEkBLeSABlvNu9sqPvnwkpAUElBY5y0kD74,2600
+routingpy/client_default.py,sha256=EZZkVGXyQDEhay1BGe8_q44XoIzY_HaVyIhpXLS2xSg,9018
+routingpy/convert.py,sha256=H-dKlYdQgV_CqAKj56vSEk0XjMCzBEiBpdBjAZfnliM,3000
+routingpy/direction.py,sha256=p25P2M3GXRkdx0wdbIiUsP1dPMtmuyqbLXtSZqLFJpE,3877
+routingpy/exceptions.py,sha256=2rd8ZKsk3mC3FBbUVGRJfturTTZ_Uqe5DFuWHN8kiNk,2064
+routingpy/expansion.py,sha256=zTIHCFs5Iz5lHZLmDsE6cH2qWxHD6BDrSi7mKCS4FHI,4659
+routingpy/isochrone.py,sha256=AU8eIFpkg9IRVkF98qNBXvzk7weeRVer6S8hfRAit5g,3194
+routingpy/matrix.py,sha256=v9mkq8Ju5GLY_UUgfkh1op5SzfgAB85R67UbWrtrvFQ,2710
+routingpy/raster.py,sha256=K_3W6oucc3wzGKIBe7YQCeCZdnN_sRtZvgBP2c9nxBI,1411
 routingpy/utils.py,sha256=zMWRy2VkgMDM-BvhZaLi5GTZOQfu--QJhqfVBJWBmu4,4070
-routingpy/valhalla_attributes.py,sha256=QLrSd3cDpa37q1aNwq4dV5c52mxPrOzHACqL55RECYQ,12312
-routingpy/routers/__init__.py,sha256=q-NIe1fJhnKVud1uX5DJW-SxVHi98Sv79wdGNW_llM4,3101
-routingpy/routers/google.py,sha256=kfWrk7LgfROjWJnhBAGhwG0325OQ_yrXw_E45L-nd0s,21028
-routingpy/routers/graphhopper.py,sha256=N3BR8SaPTLtS3NtQUdymSOstG6NSTwT18i1HMz2CcdM,25096
-routingpy/routers/heremaps.py,sha256=PNZPhl-UocwCKGBHSY3-FBcO4s3XcFyz80n6v8Mj__g,63224
-routingpy/routers/mapbox_osrm.py,sha256=X5zdouk5jHObwBzkDxKnIpKAW9MYBpiPRh505HY_9vI,20907
-routingpy/routers/mapbox_valhalla.py,sha256=yD4pj-JYpVbXbHcU-UrbK7g1FlWEzR1kd6Cunehhki8,3116
-routingpy/routers/openrouteservice.py,sha256=g3E5Y8MDnHDidwgd6Bo7DWhoCslkeO4npf4NruZ95Fw,21799
-routingpy/routers/osrm.py,sha256=izzyl0rKOmzk3cRLA_WA_woYIuuMoz9zMPyszUtdxrM,16183
-routingpy/routers/valhalla.py,sha256=d7pI8XOareQfLB0bzaIyTjkako0XOSPMf55K5OrmhwQ,37388
-routingpy-1.2.1.dist-info/AUTHORS.md,sha256=URYLg7QvpRk-nq8TnOCqaioLmsHhpdTON3YWhPIltrk,110
-routingpy-1.2.1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-routingpy-1.2.1.dist-info/METADATA,sha256=aCz9AX3qVp05BDoGNvNGWkkV5wNud-a5_FF1E2aYLqY,15174
-routingpy-1.2.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-routingpy-1.2.1.dist-info/top_level.txt,sha256=tkOfSlcXT6ZuwFGxl582I2OET27feEHcelH_gzVV-JA,10
-routingpy-1.2.1.dist-info/RECORD,,
+routingpy/valhalla_attributes.py,sha256=dTdYUmwYVAblI25Oxqox-GjVyNzggPdidIBQbhXrhgI,12259
+routingpy/routers/__init__.py,sha256=lIQc_IoLI9x7DrFJBAbJZoZdgpN_cFCi6JMVcZBWNbc,3194
+routingpy/routers/google.py,sha256=uIrseRnXSPudEt8YLwhb46yAxd6h0i9K8uBnsAc9eFk,21548
+routingpy/routers/graphhopper.py,sha256=E7YB8ZSNfnNImyBbXjEm3qjk8JPVUwbbbnpIY1OmEic,26114
+routingpy/routers/heremaps.py,sha256=aZydKzsO8VfIsL8jgnuKlZF_Pyrq0E0E-fZhN2VcqQo,65415
+routingpy/routers/mapbox_osrm.py,sha256=H4MvGLWAX5SdpDfNcw8c0VmThiGDGPoaMgcz30gNgYI,21764
+routingpy/routers/openrouteservice.py,sha256=llQfp7jLWgQbA0TTnYKaS1vfaxh-_n5kGmH35C0Gvvg,22668
+routingpy/routers/opentripplanner_v2.py,sha256=WAyEXF1AMGSthADl5kICMTJNkpUdM_3UBV1-40DOEHw,12152
+routingpy/routers/osrm.py,sha256=DSrqm3a2lqx8a8Qh8-cORl5GvYx-PvLWWqfx0fGIH2o,16712
+routingpy/routers/valhalla.py,sha256=xGhT9AtekYo8S25WfPHMjGWawhUQDr_ba4n44gD0EME,36872
+routingpy-1.3.0.dist-info/AUTHORS.md,sha256=URYLg7QvpRk-nq8TnOCqaioLmsHhpdTON3YWhPIltrk,110
+routingpy-1.3.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+routingpy-1.3.0.dist-info/METADATA,sha256=UnerdEqxcoGKYmYt5N9VP3j2dKjNcjTtOY-rCngFf1c,15205
+routingpy-1.3.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+routingpy-1.3.0.dist-info/top_level.txt,sha256=tkOfSlcXT6ZuwFGxl582I2OET27feEHcelH_gzVV-JA,10
+routingpy-1.3.0.dist-info/RECORD,,
```

