# Comparing `tmp/caustic-0.4.1-py2.py3-none-any.whl.zip` & `tmp/caustic-0.4.2-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,39 +1,39 @@
-Zip file size: 46817 bytes, number of entries: 37
--rw-rw-r--  2.0 unx      246 b- defN 23-Jul-13 15:14 caustic/__init__.py
+Zip file size: 46940 bytes, number of entries: 37
+-rw-rw-r--  2.0 unx      246 b- defN 23-Aug-03 16:00 caustic/__init__.py
 -rw-rw-r--  2.0 unx      598 b- defN 23-Jul-11 16:51 caustic/constants.py
 -rw-rw-r--  2.0 unx     9172 b- defN 23-Jul-12 17:48 caustic/cosmology.py
 -rw-rw-r--  2.0 unx     3685 b- defN 23-Jul-11 16:51 caustic/forward_raytrace.py
 -rw-rw-r--  2.0 unx     5899 b- defN 23-Jul-11 16:51 caustic/namespace_dict.py
 -rw-rw-r--  2.0 unx      155 b- defN 23-Jul-11 16:51 caustic/packed.py
--rw-rw-r--  2.0 unx     2936 b- defN 23-Jul-13 15:13 caustic/parameter.py
--rw-rw-r--  2.0 unx    19075 b- defN 23-Jul-13 15:13 caustic/parametrized.py
--rw-rw-r--  2.0 unx      654 b- defN 23-Jul-13 15:13 caustic/simulator.py
--rw-rw-r--  2.0 unx    11725 b- defN 23-Jul-13 15:13 caustic/utils.py
+-rw-rw-r--  2.0 unx     2758 b- defN 23-Aug-03 15:59 caustic/parameter.py
+-rw-rw-r--  2.0 unx    18895 b- defN 23-Aug-03 15:59 caustic/parametrized.py
+-rw-rw-r--  2.0 unx      654 b- defN 23-Jul-13 16:49 caustic/simulator.py
+-rw-rw-r--  2.0 unx    11645 b- defN 23-Aug-03 15:59 caustic/utils.py
 -rw-rw-r--  2.0 unx       80 b- defN 23-Jul-11 16:51 caustic/data/__init__.py
 -rw-rw-r--  2.0 unx     1563 b- defN 23-Jul-11 16:51 caustic/data/hdf5dataset.py
 -rw-rw-r--  2.0 unx      683 b- defN 23-Jul-11 16:51 caustic/data/illustris_kappa.py
 -rw-rw-r--  2.0 unx      675 b- defN 23-Jul-11 16:51 caustic/data/probes.py
 -rw-rw-r--  2.0 unx      259 b- defN 23-Jul-11 16:51 caustic/lenses/__init__.py
--rw-rw-r--  2.0 unx    16300 b- defN 23-Jul-11 16:51 caustic/lenses/base.py
--rw-rw-r--  2.0 unx     7457 b- defN 23-Jul-12 17:48 caustic/lenses/epl.py
--rw-rw-r--  2.0 unx     3823 b- defN 23-Jul-12 17:48 caustic/lenses/external_shear.py
--rw-rw-r--  2.0 unx     5623 b- defN 23-Jul-12 17:48 caustic/lenses/multiplane.py
--rw-rw-r--  2.0 unx    10748 b- defN 23-Jul-12 17:48 caustic/lenses/nfw.py
--rw-rw-r--  2.0 unx    14158 b- defN 23-Jul-13 15:13 caustic/lenses/pixelated_convergence.py
--rw-rw-r--  2.0 unx     4096 b- defN 23-Jul-12 17:48 caustic/lenses/point.py
--rw-rw-r--  2.0 unx     7740 b- defN 23-Jul-13 15:13 caustic/lenses/pseudo_jaffe.py
--rw-rw-r--  2.0 unx     4637 b- defN 23-Jul-12 17:48 caustic/lenses/sie.py
--rw-rw-r--  2.0 unx     3489 b- defN 23-Jul-12 17:48 caustic/lenses/singleplane.py
--rw-rw-r--  2.0 unx     3578 b- defN 23-Jul-12 17:48 caustic/lenses/sis.py
+-rw-rw-r--  2.0 unx    16872 b- defN 23-Jul-31 19:58 caustic/lenses/base.py
+-rw-rw-r--  2.0 unx     7487 b- defN 23-Jul-29 18:18 caustic/lenses/epl.py
+-rw-rw-r--  2.0 unx     3853 b- defN 23-Jul-29 18:18 caustic/lenses/external_shear.py
+-rw-rw-r--  2.0 unx     5702 b- defN 23-Jul-29 18:18 caustic/lenses/multiplane.py
+-rw-rw-r--  2.0 unx    10815 b- defN 23-Jul-29 18:18 caustic/lenses/nfw.py
+-rw-rw-r--  2.0 unx    14289 b- defN 23-Aug-03 15:59 caustic/lenses/pixelated_convergence.py
+-rw-rw-r--  2.0 unx     4126 b- defN 23-Jul-29 18:18 caustic/lenses/point.py
+-rw-rw-r--  2.0 unx     7790 b- defN 23-Jul-29 18:18 caustic/lenses/pseudo_jaffe.py
+-rw-rw-r--  2.0 unx     4667 b- defN 23-Jul-29 18:18 caustic/lenses/sie.py
+-rw-rw-r--  2.0 unx     3519 b- defN 23-Jul-29 18:18 caustic/lenses/singleplane.py
+-rw-rw-r--  2.0 unx     3608 b- defN 23-Jul-29 18:18 caustic/lenses/sis.py
 -rw-rw-r--  2.0 unx     2458 b- defN 23-Jul-11 16:51 caustic/lenses/utils.py
 -rw-rw-r--  2.0 unx       89 b- defN 23-Jul-11 16:51 caustic/sources/__init__.py
--rw-rw-r--  2.0 unx     2000 b- defN 23-Jul-11 16:51 caustic/sources/base.py
--rw-rw-r--  2.0 unx     3728 b- defN 23-Jul-13 15:13 caustic/sources/pixelated.py
+-rw-rw-r--  2.0 unx     2044 b- defN 23-Jul-29 18:18 caustic/sources/base.py
+-rw-rw-r--  2.0 unx     3866 b- defN 23-Aug-03 15:59 caustic/sources/pixelated.py
 -rw-rw-r--  2.0 unx      792 b- defN 23-Jul-11 16:51 caustic/sources/probes.py
--rw-rw-r--  2.0 unx     5002 b- defN 23-Jul-13 15:13 caustic/sources/sersic.py
--rw-rw-r--  2.0 unx     1076 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3393 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/WHEEL
--rw-rw-r--  2.0 unx        8 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2978 b- defN 23-Jul-13 15:15 caustic-0.4.1.dist-info/RECORD
-37 files, 160688 bytes uncompressed, 42115 bytes compressed:  73.8%
+-rw-rw-r--  2.0 unx     5012 b- defN 23-Jul-29 18:18 caustic/sources/sersic.py
+-rw-rw-r--  2.0 unx     1076 b- defN 23-Aug-03 16:01 caustic-0.4.2.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3393 b- defN 23-Aug-03 16:01 caustic-0.4.2.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Aug-03 16:01 caustic-0.4.2.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        8 b- defN 23-Aug-03 16:01 caustic-0.4.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2978 b- defN 23-Aug-03 16:01 caustic-0.4.2.dist-info/RECORD
+37 files, 161521 bytes uncompressed, 42238 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -90,23 +90,23 @@
 
 Filename: caustic/sources/probes.py
 Comment: 
 
 Filename: caustic/sources/sersic.py
 Comment: 
 
-Filename: caustic-0.4.1.dist-info/LICENSE
+Filename: caustic-0.4.2.dist-info/LICENSE
 Comment: 
 
-Filename: caustic-0.4.1.dist-info/METADATA
+Filename: caustic-0.4.2.dist-info/METADATA
 Comment: 
 
-Filename: caustic-0.4.1.dist-info/WHEEL
+Filename: caustic-0.4.2.dist-info/WHEEL
 Comment: 
 
-Filename: caustic-0.4.1.dist-info/top_level.txt
+Filename: caustic-0.4.2.dist-info/top_level.txt
 Comment: 
 
-Filename: caustic-0.4.1.dist-info/RECORD
+Filename: caustic-0.4.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## caustic/__init__.py

```diff
@@ -1,8 +1,8 @@
-__version__ = '0.4.1'
+__version__ = '0.4.2'
 
 from .constants import *
 from .lenses import *
 from .cosmology import *
 from .forward_raytrace import *
 from .packed import *
 from .parametrized import *
```

## caustic/parameter.py

```diff
@@ -26,18 +26,14 @@
             if shape is None:
                 raise ValueError("If value is None, a shape must be provided")
             if not isinstance(shape, tuple):
                 raise TypeError("The shape of a parameter must be a tuple")
             self._shape = shape
         else:
             value = torch.as_tensor(value)
-            if shape != value.shape:
-                raise ValueError(
-                    f"value's shape {value.shape} does not match provided shape {shape}"
-                )
             self._shape = value.shape
         self._value = value
         self._dtype = None if value is None else value.dtype
 
     @property
     def static(self) -> bool:
         return not self.dynamic
```

## caustic/parametrized.py

```diff
@@ -42,17 +42,14 @@
             name = self._default_name()
         if not isinstance(name, str):
             raise ValueError(f"name must be a string (received {name})")
         self._name = name
         self._parents: OrderedDict[str, Parametrized] = NamespaceDict()
         self._params: OrderedDict[str, Parameter] = NamespaceDict()
         self._childs: OrderedDict[str, Parametrized] = NamespaceDict()
-        self._dynamic_size = 0
-        self._n_dynamic = 0
-        self._n_static = 0
         self._module_key_map = {}
    
     def _default_name(self):
         return re.search("([A-Z])\w+", str(self.__class__)).group()
     
     def __getattribute__(self, key):
         try:
@@ -146,32 +143,26 @@
             name (str): The name of the parameter.
             value (Optional[Tensor], optional): The value of the parameter. Defaults to None.
             shape (Optional[tuple[int, ...]], optional): The shape of the parameter. Defaults to an empty tuple.
         """
         self._params[name] = Parameter(value, shape)
         # __setattr__ inside add_param to catch all uses of this method
         super().__setattr__(name, self._params[name]) 
-        if getattr(self, name).dynamic:
-            size = prod(shape)
-            self._dynamic_size += size
-            self._n_dynamic += 1
-        else:
-            self._n_static += 1
 
     @property
     def n_dynamic(self) -> int:
-        return self._n_dynamic
+        return len(self.module_params.dynamic)
 
     @property
     def n_static(self) -> int:
-        return self._n_static
+        return len(self.module_params.static)
 
     @property
     def dynamic_size(self) -> int:
-        return self._dynamic_size
+        return sum(prod(dyn.shape) for dyn in self.module_params.dynamic.values())
 
     def pack(
         self,
         x: Union[
             list[Tensor],
             dict[str, Union[list[Tensor], Tensor, dict[str, Tensor]]],
             Tensor,
@@ -386,16 +377,16 @@
         import graphviz
 
         def add_component(p: Parametrized, dot):
             dot.attr("node", style="solid", color="black", shape="ellipse")
             dot.node(p.name, f"{p.__class__.__name__}('{p.name}')")
 
         def add_params(p: Parametrized, dot):
-            static = p.module_params.static
-            dynamic = p.module_params.dynamic
+            static = p.module_params.static.keys()
+            dynamic = p.module_params.dynamic.keys()
 
             dot.attr("node", style="solid", color="black", shape="box")
             for n in dynamic:
                 if show_dynamic_params:
                     dot.node(f"{p.name}/{n}", n)
                     dot.edge(p.name, f"{p.name}/{n}")
```

## caustic/utils.py

```diff
@@ -93,26 +93,16 @@
         ny (int): The number of grid points along the y-axis.
         device (torch.device, optional): The device on which to create the tensor. Defaults to None.
         dtype (torch.dtype, optional): The desired data type of the tensor. Defaults to torch.float32.
 
     Returns:
         Tuple[Tensor, Tensor]: The generated meshgrid as a tuple of Tensors.
     """
-    xs = (
-        torch.linspace(-1, 1, nx, device=device, dtype=dtype)
-        * resolution
-        * (nx - 1)
-        / 2
-    )
-    ys = (
-        torch.linspace(-1, 1, ny, device=device, dtype=dtype)
-        * resolution
-        * (ny - 1)
-        / 2
-    )
+    xs = torch.linspace(-1, 1, nx, device=device, dtype=dtype) * resolution * (nx - 1) / 2
+    ys = torch.linspace(-1, 1, ny, device=device, dtype=dtype) * resolution * (ny - 1) / 2
     return torch.meshgrid([xs, ys], indexing="xy")
 
 
 def safe_divide(num, denom):
     """
     Safely divides two tensors, returning zero where the denominator is zero.
```

## caustic/lenses/base.py

```diff
@@ -4,15 +4,15 @@
 import warnings
 
 import torch
 from torch import Tensor
 
 from ..constants import arcsec_to_rad, c_Mpc_s
 from ..cosmology import Cosmology
-from ..parametrized import Parametrized
+from ..parametrized import Parametrized, unpack
 from .utils import get_magnification
 
 __all__ = ("ThinLens", "ThickLens")
 
 class ThickLens(Parametrized):
     """
     Base class for modeling gravitational lenses that cannot be treated using the thin lens approximation.
@@ -29,16 +29,17 @@
         Args:
             name (str): The name of the lens model.
             cosmology (Cosmology): An instance of a Cosmology class that describes the cosmological parameters of the model.
         """
         super().__init__(name)
         self.cosmology = cosmology
 
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         ThickLens objects do not have a reduced deflection angle since the distance D_ls is undefined
         
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -47,16 +48,17 @@
 
         Raises:
             NotImplementedError
         """
         warnings.warn("ThickLens objects do not have a reduced deflection angle since they have no unique lens redshift. The distance D_{ls} is undefined in the equation $\alpha_{reduced} = \frac{D_{ls}}{D_s}\alpha_{physical}$. See `effective_reduced_deflection_angle`. Now using effective_reduced_deflection_angle, please switch functions to remove this warning")
         return self.effective_reduced_deflection_angle(x, y, z_s, params)
 
+    @unpack(3)
     def effective_reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """ThickLens objects do not have a reduced deflection angle since the
         distance D_ls is undefined. Instead we define an effective
         reduced deflection angle by simply assuming the relation
         $\alpha = \theta - \beta$ holds, where $\alpha$ is the
         effective reduced deflection angle, $\theta$ are the observed
         angular coordinates, and $\beta$ are the angular coordinates
@@ -67,17 +69,18 @@
             y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
             params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         """
         bx, by = self.raytrace(x, y, z_s, params)
         return x - bx, y - by
-    
+
+    @unpack(3)
     def physical_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """Physical deflection angles are computed with respect to a lensing
         plane. ThickLens objects have no unique definition of a lens
         plane and so cannot compute a physical_deflection_angle
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
@@ -88,16 +91,17 @@
         Returns:
             tuple[Tensor, Tensor]: Tuple of Tensors representing the x and y components of the deflection angle, respectively.
 
         """
         raise NotImplementedError("Physical deflection angles are computed with respect to a lensing plane. ThickLens objects have no unique definition of a lens plane and so cannot compute a physical_deflection_angle")
 
     @abstractmethod
+    @unpack(3)
     def raytrace(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """Performs ray tracing by computing the angular position on the
         source plance associated with a given input observed angular
         coordinate x,y.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
@@ -108,16 +112,17 @@
         Returns:
             tuple[Tensor, Tensor]: Tuple of Tensors representing the x and y coordinates of the ray-traced light rays, respectively.
 
         """
         ...
 
     @abstractmethod
+    @unpack(3)
     def surface_density(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Computes the projected mass density at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -126,16 +131,17 @@
 
         Returns:
             Tensor: The projected mass density at the given coordinates in units of solar masses per square Megaparsec.
         """
         ...
 
     @abstractmethod
+    @unpack(3)
     def time_delay(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Computes the gravitational time delay at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -143,15 +149,16 @@
             params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             Tensor: The gravitational time delay at the given coordinates.
         """
         ...
 
-    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None) -> Tensor:
+    @unpack(3)
+    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs) -> Tensor:
         """
         Computes the gravitational lensing magnification at given coordinates.
     
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
@@ -180,16 +187,17 @@
 
     def __init__(self, cosmology: Cosmology, z_l: Optional[Union[Tensor, float]] = None, name: str = None):
         super().__init__(name)
         self.cosmology = cosmology
         self.add_param("z_l", z_l)
 
     @abstractmethod
+    @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Computes the reduced deflection angle of the lens at given coordinates [arcsec].
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -197,16 +205,17 @@
             params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns:
             tuple[Tensor, Tensor]: Reduced deflection angle in x and y directions.
         """
         ...
 
+    @unpack(3)
     def physical_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Computes the physical deflection angle immediately after passing through this lens's plane.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -220,16 +229,17 @@
 
         d_s = self.cosmology.angular_diameter_distance(z_s, params)
         d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
         deflection_angle_x, deflection_angle_y = self.reduced_deflection_angle(x, y, z_s, params)
         return (d_s / d_ls) * deflection_angle_x, (d_s / d_ls) * deflection_angle_y
 
     @abstractmethod
+    @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Computes the convergence of the lens at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -238,32 +248,34 @@
 
         Returns:
             Tensor: Convergence at the given coordinates.
         """
         ...
 
     @abstractmethod
+    @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Computes the gravitational lensing potential at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
             params (Packed, optional): Dynamic parameter container for the lens model. Defaults to None.
 
         Returns: Tensor: Gravitational lensing potential at the given coordinates in arcsec^2.
         """
         ...
 
+    @unpack(3)
     def surface_density(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Computes the surface mass density of the lens at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -275,16 +287,17 @@
         """
         # Superclass params come before subclass ones
         z_l = self.unpack(params)[0]
 
         critical_surface_density = self.cosmology.critical_surface_density(z_l, z_s, params)
         return self.convergence(x, y, z_s, params) * critical_surface_density
 
+    @unpack(3)
     def raytrace(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Perform a ray-tracing operation by subtracting the deflection angles from the input coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -293,16 +306,17 @@
 
         Returns:
             tuple[Tensor, Tensor]: Ray-traced coordinates in the x and y directions.
         """
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         return x - ax, y - ay
 
+    @unpack(3)
     def time_delay(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ):
         """
         Compute the gravitational time delay for light passing through the lens at given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -319,16 +333,17 @@
         d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         potential = self.potential(x, y, z_s, params)
         factor = (1 + z_l) / c_Mpc_s * d_s * d_l / d_ls
         fp = 0.5 * d_ls**2 / d_s**2 * (ax**2 + ay**2) - potential
         return factor * fp * arcsec_to_rad**2
 
+    @unpack(3)
     def _lensing_jacobian_fft_method(
-        self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing Jacobian using the Fast Fourier Transform method.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
@@ -353,15 +368,16 @@
         j1 = torch.stack(
             [1 - potential_xx, -potential_xy], dim=-1
         )  # Equation 2.33 from Meneghetti lensing lectures
         j2 = torch.stack([-potential_xy, 1 - potential_yy], dim=-1)
         jacobian = torch.stack([j1, j2], dim=-1)
         return jacobian
 
-    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, params: Optional["Packed"] = None) -> Tensor:
+    @unpack(3)
+    def magnification(self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs) -> Tensor:
         """
         Compute the gravitational magnification at the given coordinates.
 
         Args:
             x (Tensor): Tensor of x coordinates in the lens plane.
             y (Tensor): Tensor of y coordinates in the lens plane.
             z_s (Tensor): Tensor of source redshifts.
```

## caustic/lenses/epl.py

```diff
@@ -72,15 +72,15 @@
         self.add_param("t", t)
         self.s = s
 
         self.n_iter = n_iter
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angles of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
@@ -129,15 +129,15 @@
             omega_i = -f * factor * phi * omega_i
             part_sum = part_sum + omega_i
 
         return part_sum
 
     @unpack(3)
     def potential(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None, **kwargs
     ):
         """
         Compute the lensing potential of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
@@ -150,15 +150,15 @@
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
         x, y = translate_rotate(x, y, x0, y0, phi)
         return (x * ax + y * ay) / (2 - t)
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, t, *args, params: Optional["Packed"] = None, **kwargs
     ):
         """
         Compute the convergence of the lens, which describes the local density of the lens.
 
         Args:
             x (Tensor): X coordinates in the lens plane.
             y (Tensor): Y coordinates in the lens plane.
```

## caustic/lenses/external_shear.py

```diff
@@ -40,15 +40,15 @@
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("gamma_1", gamma_1)
         self.add_param("gamma_2", gamma_2)
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Calculates the reduced deflection angle.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -62,15 +62,15 @@
         # Meneghetti eq 3.83
         a1 = x * gamma_1 + y * gamma_2
         a2 = x * gamma_2 - y * gamma_1
         return a1, a2  # I'm not sure but I think no derotation necessary
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculates the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -82,15 +82,15 @@
         """
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         x, y = translate_rotate(x, y, x0, y0)
         return 0.5 * (x * ax + y * ay)
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, gamma_1, gamma_2, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         The convergence is undefined for an external shear.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/multiplane.py

```diff
@@ -25,15 +25,16 @@
     """
     def __init__(self, cosmology: Cosmology, lenses: list[ThinLens], name: str = None):
         super().__init__(cosmology, name=name)
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
 
-    def get_z_ls(self, params: Optional["Packed"]) -> list[Tensor]:
+    @unpack(0)
+    def get_z_ls(self, *args, params: Optional["Packed"] = None, **kwargs) -> list[Tensor]:
         """
         Get the redshifts of each lens in the multiplane.
 
         Args:
             params (Packed, optional): Dynamic parameter container.
 
         Returns:
@@ -41,15 +42,15 @@
         """
         # Relies on z_l being the first element to be unpacked, which should always
         # be the case for a ThinLens
         return [lens.unpack(params)[0] for lens in self.lenses]
 
     @unpack(3)
     def raytrace(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """Calculate the angular source positions corresponding to the
         observer positions x,y. See Margarita et al. 2013 for the
         formalism from the GLAMER -II code:
         https://ui.adsabs.harvard.edu/abs/2014MNRAS.445.1954P/abstract
 
         Args:
@@ -108,22 +109,22 @@
         if X_ip1 is None or Y_ip1 is None:
             return x, y
         else:
             return X_ip1 / D_0_s, Y_ip1 / D_0_s
 
     @unpack(3)
     def effective_reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         bx, by = self.raytrace(x, y, z_s, params)
         return x - bx, y - by
 
     @unpack(3)
     def surface_density(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -137,15 +138,15 @@
             NotImplementedError: This method is not yet implemented.
         """
         # TODO: rescale mass densities of each lens and sum
         raise NotImplementedError()
 
     @unpack(3)
     def time_delay(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the time delay of light caused by the lensing.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/nfw.py

```diff
@@ -76,15 +76,15 @@
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("m", m)
         self.add_param("c", c)
         self.s = s
 
     @unpack(0)
-    def get_scale_radius(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"]) -> Tensor:
+    def get_scale_radius(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs) -> Tensor:
         """
         Calculate the scale radius of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             m (Tensor): Mass of the lens.
             c (Tensor): Concentration parameter of the lens.
@@ -94,15 +94,15 @@
             Tensor: The scale radius of the lens in Mpc.
         """
         critical_density = self.cosmology.critical_density(z_l, params)
         r_delta = (3 * m / (4 * pi * DELTA * critical_density)) ** (1 / 3)
         return 1 / c * r_delta
 
     @unpack(0)
-    def get_scale_density(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None) -> Tensor:
+    def get_scale_density(self, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs) -> Tensor:
         """
         Calculate the scale density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             c (Tensor): Concentration parameter of the lens.
             params (Packed, optional): Dynamic parameter container.
@@ -115,15 +115,15 @@
             / 3
             * self.cosmology.critical_density(z_l, params)
             * c**3
             / ((1 + c).log() - c / (1 + c))
         )
 
     @unpack(1)
-    def get_convergence_s(self, z_s, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None) -> Tensor:
+    def get_convergence_s(self, z_s, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs) -> Tensor:
         """
         Calculate the dimensionless surface mass density of the lens.
 
         Args:
             z_l (Tensor): Redshift of the lens.
             z_s (Tensor): Redshift of the source.
             m (Tensor): Mass of the lens.
@@ -199,15 +199,15 @@
                 1.0 + torch.tensor(1 / 2).log(),
             ),
         )
         return term_2
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the reduced deflection angle.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -239,15 +239,15 @@
         ay = deflection_angle * y / th
         d_s = self.cosmology.angular_diameter_distance(z_s, params)
         d_ls = self.cosmology.angular_diameter_distance_z1z2(z_l, z_s, params)
         return ax * d_ls / d_s, ay * d_ls / d_s
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -264,15 +264,15 @@
         xi = d_l * th * arcsec_to_rad
         r = xi / scale_radius  # xi / xi_0
         convergence_s = self.get_convergence_s(z_s, params)
         return 2 * convergence_s * self._f(r) / (r**2 - 1)
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, m, c, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/pixelated_convergence.py

```diff
@@ -12,15 +12,15 @@
 from ..parametrized import unpack
 
 __all__ = ("PixelatedConvergence",)
 
 class PixelatedConvergence(ThinLens):
     def __init__(
         self,
-        fov: float,
+        pixelscale: float,
         n_pix: int,
         cosmology: Cosmology,
         z_l: Optional[Tensor] = None,
         x0: Optional[Tensor] = torch.tensor(0.0),
         y0: Optional[Tensor] = torch.tensor(0.0),
         convergence_map: Optional[Tensor] = None,
         shape: Optional[tuple[int, ...]] = None,
@@ -67,23 +67,23 @@
             )
 
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("convergence_map", convergence_map, shape)
 
         self.n_pix = n_pix
-        self.fov = fov
-        self.res = fov / n_pix
+        self.pixelscale = pixelscale
+        self.fov = self.n_pix * self.pixelscale
         self.use_next_fast_len = use_next_fast_len
 
         # Construct kernels
-        x_mg, y_mg = get_meshgrid(self.res, 2 * self.n_pix, 2 * self.n_pix)
+        x_mg, y_mg = get_meshgrid(self.pixelscale, 2 * self.n_pix, 2 * self.n_pix)
         # Shift to center kernels within pixel at index n_pix
-        x_mg = x_mg - self.res / 2
-        y_mg = y_mg - self.res / 2
+        x_mg = x_mg - self.pixelscale / 2
+        y_mg = y_mg - self.pixelscale / 2
         d2 = x_mg**2 + y_mg**2
         self.potential_kernel = safe_log(d2.sqrt())
         self.ax_kernel = safe_divide(x_mg, d2)
         self.ay_kernel = safe_divide(y_mg, d2)
         # Set centers of kernels to zero
         self.potential_kernel[..., self.n_pix, self.n_pix] = 0
         self.ax_kernel[..., self.n_pix, self.n_pix] = 0
@@ -189,15 +189,15 @@
         else:
             raise ValueError("invalid convolution convolution_mode")
 
         self._convolution_mode = convolution_mode
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles at the specified positions using the given convergence map.
 
         Args:
             x (Tensor): The x-coordinates of the positions to compute the deflection angles for.
             y (Tensor): The y-coordinates of the positions to compute the deflection angles for.
@@ -230,18 +230,18 @@
             convergence_map (Tensor): The 2D tensor representing the convergence map.
 
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles.
         """
         convergence_tilde = self._fft2_padded(convergence_map)
         deflection_angle_x = torch.fft.irfft2(convergence_tilde * self.ax_kernel_tilde, self._s) * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         deflection_angle_y = torch.fft.irfft2(convergence_tilde * self.ay_kernel_tilde, self._s) * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         return self._unpad_fft(deflection_angle_x), self._unpad_fft(deflection_angle_y)
 
     def _deflection_angle_conv2d(self, convergence_map: Tensor) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles using the 2D convolution method.
 
@@ -251,24 +251,24 @@
         Returns:
             tuple[Tensor, Tensor]: The x and y components of the deflection angles.
         """
         # Use convergence_map as kernel since the kernel is twice as large. Flip since
         # we actually want the cross-correlation.
         convergence_map_flipped = convergence_map.flip((-1, -2))[None, None]
         deflection_angle_x = F.conv2d(self.ax_kernel[None, None], convergence_map_flipped)[0, 0] * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         deflection_angle_y = F.conv2d(self.ay_kernel[None, None], convergence_map_flipped)[0, 0] * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         return self._unpad_conv2d(deflection_angle_x), self._unpad_conv2d(deflection_angle_y)
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential at the specified positions using the given convergence map.
 
         Args:
         x (Tensor): The x-coordinates of the positions to compute the lensing potential for.
         y (Tensor): The y-coordinates of the positions to compute the lensing potential for.
@@ -297,15 +297,15 @@
             convergence_map (Tensor): The 2D tensor representing the convergence map.
     
         Returns:
             Tensor: The lensing potential.
         """
         convergence_tilde = self._fft2_padded(convergence_map)
         potential = torch.fft.irfft2(convergence_tilde * self.potential_kernel_tilde, self._s) * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         return self._unpad_fft(potential)
 
     def _potential_conv2d(self, convergence_map: Tensor) -> Tensor:
         """
         Compute the lensing potential using the 2D convolution method.
     
@@ -315,21 +315,21 @@
         Returns:
             Tensor: The lensing potential.
         """
         # Use convergence_map as kernel since the kernel is twice as large. Flip since
         # we actually want the cross-correlation.
         convergence_map_flipped = convergence_map.flip((-1, -2))[None, None]
         potential = F.conv2d(self.potential_kernel[None, None], convergence_map_flipped)[0, 0] * (
-            self.res**2 / pi
+            self.pixelscale**2 / pi
         )
         return self._unpad_conv2d(potential)
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_map, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the convergence at the specified positions. This method is not implemented.
     
         Args:
             x (Tensor): The x-coordinates of the positions to compute the convergence for.
             y (Tensor): The y-coordinates of the positions to compute the convergence for.
@@ -339,9 +339,9 @@
         Returns:
             Tensor: The convergence at the specified positions.
     
         Raises:
             NotImplementedError: This method is not implemented.
         """
         return interp2d(
-            convergence_map, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
+            convergence_map, (x - x0).view(-1) / self.fov*2, (y - y0).view(-1) / self.fov*2
         ).reshape(x.shape)
```

## caustic/lenses/point.py

```diff
@@ -50,15 +50,15 @@
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Compute the deflection angles.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -72,15 +72,15 @@
         th = (x**2 + y**2).sqrt() + self.s
         ax = x / th**2 * th_ein**2
         ay = y / th**2 * th_ein**2
         return ax, ay
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
@@ -92,15 +92,15 @@
         """
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         return th_ein**2 * th.log()
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the convergence (dimensionless surface mass density).
 
         Args:
             x (Tensor): x-coordinates in the lens plane.
             y (Tensor): y-coordinates in the lens plane.
```

## caustic/lenses/pseudo_jaffe.py

```diff
@@ -62,15 +62,15 @@
         self.add_param("y0", y0)
         self.add_param("convergence_0", convergence_0)
         self.add_param("core_radius", core_radius)
         self.add_param("scale_radius", scale_radius)
         self.s = s
 
     @unpack(2)
-    def mass_enclosed_2d(self, theta, z_s, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None):
+    def mass_enclosed_2d(self, theta, z_s, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None, **kwargs):
         """
         Calculate the mass enclosed within a two-dimensional radius.
 
         Args:
             theta (Tensor): Radius at which to calculate enclosed mass.
             z_s (Tensor): Source redshift.
             params (Packed, optional): Dynamic parameter container.
@@ -100,15 +100,15 @@
         z_l,
         z_s,
         rho_0,
         core_radius,
         scale_radius,
         cosmology: Cosmology,
         *args,
-        params: Optional["Packed"] = None,
+        params: Optional["Packed"] = None, **kwargs,
     ):
         """
         Compute the central convergence.
 
         Args:
             z_l (Tensor): Lens redshift.
             z_s (Tensor): Source redshift.
@@ -128,15 +128,15 @@
             * scale_radius
             / (core_radius + scale_radius)
             / cosmology.critical_surface_density(z_l, z_s, params = params)
         )
 
     @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """ Calculate the deflection angle.
 
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
             z_s (Tensor): Source redshift.
@@ -153,15 +153,15 @@
         alpha = 2 * convergence_0 * core_radius * scale_radius / (scale_radius - core_radius) * f
         ax = alpha * x / R
         ay = alpha * y / R
         return ax, ay
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential. This calculation is based on equation A18.
     
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
@@ -179,15 +179,15 @@
             - (core_radius**2 + R_squared).sqrt()
             + core_radius * (core_radius + (core_radius**2 + R_squared).sqrt()).log()
             - scale_radius * (scale_radius + (scale_radius**2 + R_squared).sqrt()).log()
         )
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, convergence_0, core_radius, scale_radius, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculate the projected mass density, based on equation A6.
     
         Args:
             x (Tensor): x-coordinate of the lens.
             y (Tensor): y-coordinate of the lens.
```

## caustic/lenses/sie.py

```diff
@@ -63,15 +63,15 @@
         Returns:
             Tensor: The radial coordinate in the lens plane.
         """
         return (q**2 * (x**2 + self.s**2) + y**2).sqrt()
 
     @unpack(3)
     def reduced_deflection_angle(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the physical deflection angle.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -87,15 +87,15 @@
         ax = b * q.sqrt() / f * (f * x / (psi + self.s)).atan()
         ay = b * q.sqrt() / f * (f * y / (psi + q**2 * self.s)).atanh()
 
         return derotate(ax, ay, phi)
 
     @unpack(3)
     def potential( 
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -108,15 +108,15 @@
         ax, ay = self.reduced_deflection_angle(x, y, z_s, params)
         ax, ay = derotate(ax, ay, -phi)
         x, y = translate_rotate(x, y, x0, y0, phi)
         return x * ax + y * ay
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, q, phi, b, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculate the projected mass density.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
```

## caustic/lenses/singleplane.py

```diff
@@ -29,15 +29,15 @@
         self.lenses = lenses
         for lens in lenses:
             self.add_parametrized(lens)
         # TODO: assert all z_l are the same?
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the total deflection angle by summing the deflection angles of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -53,15 +53,15 @@
             ax_cur, ay_cur = lens.reduced_deflection_angle(x, y, z_s, params)
             ax = ax + ax_cur
             ay = ay + ay_cur
         return ax, ay
 
     @unpack(3)
     def convergence(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculate the total projected mass density by summing the mass densities of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -75,15 +75,15 @@
         for lens in self.lenses:
             convergence_cur = lens.convergence(x, y, z_s, params)
             convergence = convergence + convergence_cur
         return convergence
 
     @unpack(3)
     def potential(
-            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the total lensing potential by summing the lensing potentials of all individual lenses.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
```

## caustic/lenses/sis.py

```diff
@@ -43,15 +43,15 @@
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("th_ein", th_ein)
         self.s = s
 
     @unpack(3)
     def reduced_deflection_angle(
-            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> tuple[Tensor, Tensor]:
         """
         Calculate the deflection angle of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -65,15 +65,15 @@
         R = (x**2 + y**2).sqrt() + self.s
         ax = th_ein * x / R
         ay = th_ein * y / R
         return ax, ay
 
     @unpack(3)
     def potential(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Compute the lensing potential of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
@@ -85,15 +85,15 @@
         """
         x, y = translate_rotate(x, y, x0, y0)
         th = (x**2 + y**2).sqrt() + self.s
         return th_ein * th
 
     @unpack(3)
     def convergence(
-        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None
+        self, x: Tensor, y: Tensor, z_s: Tensor, z_l, x0, y0, th_ein, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Calculate the projected mass density of the SIS lens.
 
         Args:
             x (Tensor): The x-coordinate of the lens.
             y (Tensor): The y-coordinate of the lens.
```

## caustic/sources/base.py

```diff
@@ -1,13 +1,13 @@
 from abc import abstractmethod
 from typing import Any, Optional
 
 from torch import Tensor
 
-from ..parametrized import Parametrized
+from ..parametrized import Parametrized, unpack
 
 __all__ = ("Source",)
 
 
 class Source(Parametrized):
     """
     This is an abstract base class used to represent a source in a strong gravitational lensing system. 
@@ -15,16 +15,17 @@
     The Source class inherits from the Parametrized class, implying that it contains parameters that can 
     be optimized or manipulated.
     
     The class introduces one abstract method, `brightness`, that must be implemented in any concrete 
     subclass. This method calculates the brightness of the source at given coordinates.
     """
     @abstractmethod
+    @unpack(2)
     def brightness(
-        self, x: Tensor, y: Tensor, params: Optional["Packed"] = None
+            self, x: Tensor, y: Tensor, *args, params: Optional["Packed"] = None, **kwargs
     ) -> Tensor:
         """
         Abstract method that calculates the brightness of the source at the given coordinates. 
         This method is expected to be implemented in any class that derives from Source.
         
         Args:
             x (Tensor): The x-coordinate(s) at which to calculate the source brightness.
```

## caustic/sources/pixelated.py

```diff
@@ -46,26 +46,26 @@
             pixelscale (Optional[Tensor]): The pixelscale of the source image in the lens plane in units of arcsec/pixel.
             shape (Optional[tuple[int, ...]]): The shape of the source image.
         """
         if image is not None and image.ndim not in [2, 3]:
             raise ValueError(
                 f"image must be 2D or 3D (channels first). Received a {image.ndim}D tensor)"
             )
-        elif shape is None and len(shape) not in [2, 3]:
+        elif shape is not None and len(shape) not in [2, 3]:
             raise ValueError(
                 f"shape must be specify 2D or 3D tensors. Received shape={shape}"
             )
         super().__init__(name=name)
         self.add_param("x0", x0)
         self.add_param("y0", y0)
         self.add_param("image", image, shape)
         self.add_param("pixelscale", pixelscale)
 
     @unpack(2)
-    def brightness(self, x, y, x0, y0, image, pixelscale, *args, params: Optional["Packed"] = None):
+    def brightness(self, x, y, x0, y0, image, pixelscale, *args, params: Optional["Packed"] = None, **kwargs):
         """
         Implements the `brightness` method for `Pixelated`. The brightness at a given point is 
         determined by interpolating values from the source image.
 
         Args:
             x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
@@ -74,10 +74,12 @@
             params (Optional[Packed]): A dictionary containing additional parameters that might be required to 
                 calculate the brightness. 
 
         Returns:
             Tensor: The brightness of the source at the given coordinate(s). The brightness is 
             determined by interpolating values from the source image.
         """
+        fov_x = pixelscale * image.shape[0]
+        fov_y = pixelscale * image.shape[1]
         return interp2d(
-            image, (x - x0).view(-1) / pixelscale, (y - y0).view(-1) / pixelscale
+            image, (x - x0).view(-1) / fov_x*2, (y - y0).view(-1) / fov_y*2 # make coordinates bounds at half the fov
         ).reshape(x.shape)
```

## caustic/sources/sersic.py

```diff
@@ -65,15 +65,15 @@
         self.add_param("Re", Re)
         self.add_param("Ie", Ie)
         self.s = s
 
         self.lenstronomy_k_mode = use_lenstronomy_k
 
     @unpack(2)
-    def brightness(self, x, y, x0, y0, q, phi, n, Re, Ie, *args, params: Optional["Packed"] = None):
+    def brightness(self, x, y, x0, y0, q, phi, n, Re, Ie, *args, params: Optional["Packed"] = None, **kwargs):
         """
         Implements the `brightness` method for `Sersic`. The brightness at a given point is 
         determined by the Sersic profile formula.
 
         Args:
             x (Tensor): The x-coordinate(s) at which to calculate the source brightness. 
                 This could be a single value or a tensor of values.
```

## Comparing `caustic-0.4.1.dist-info/LICENSE` & `caustic-0.4.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `caustic-0.4.1.dist-info/METADATA` & `caustic-0.4.2.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: caustic
-Version: 0.4.1
+Version: 0.4.2
 Summary: The lensing pipeline of the future.
 Author-email: Connor Stone <connorstone628@gmail.com>, Adam Coogan <dr.adam.coogan@gmail.com>
 License: MIT License
         
         Copyright (c) [2023] [caustic authors]
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `caustic-0.4.1.dist-info/RECORD` & `caustic-0.4.2.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-caustic/__init__.py,sha256=2Jkg-g2fIuwHs-_6P6EBzM-BlFyd80_bOyKloRfxJbo,246
+caustic/__init__.py,sha256=dxzl_Jh6FFHddrBtde6tm1A-nCeFoVNuktyncgnrT5g,246
 caustic/constants.py,sha256=DDuzUgDSeOGtqhEuhkmJIYmV4FkmqZfVm_AzvjDSIYc,598
 caustic/cosmology.py,sha256=lp4KuhoyQPCO5bg5Jkr30NENWoXvqTm1CYuaOSUEzwI,9172
 caustic/forward_raytrace.py,sha256=K5_WUaFyfWtLgL1AgDXotxFjrsOVPBHJdNQYDnagwkc,3685
 caustic/namespace_dict.py,sha256=Py-_zjFVn_T3E_B6u12zdjJjhoR2LeamT9x7CTLn9Mc,5899
 caustic/packed.py,sha256=hSgey6KbDgfNOoxVY4pFBtp4kt_2w48nBm5wUz52nuY,155
-caustic/parameter.py,sha256=9MMd_okt6Gue8epOQFEI7pYRTygi5lp4-inxCbY34wY,2936
-caustic/parametrized.py,sha256=wPk0n9D-yPGVikN8NSSppf9EePhJomSw7MsIc1W7RRA,19075
+caustic/parameter.py,sha256=ZnzN3DCAQ7VDB-iAjJrhFG3FBZuxARrE5S3KS5bxQJw,2758
+caustic/parametrized.py,sha256=_d36k5BMnOUVBLsveR7DnMLOD-9Tkf0YfpsZLFogDv8,18895
 caustic/simulator.py,sha256=CnhrEfKBEu9lAou0BQPs9QxiGJ-JWlsDeINe3j3WYgg,654
-caustic/utils.py,sha256=WBSgT9NCVyM-XKxazyisj101Yi2L7IouKq19woPmknI,11725
+caustic/utils.py,sha256=HYo4ADtPGbUsicuTfFz67_CrQR925J_-v_LoBW3buog,11645
 caustic/data/__init__.py,sha256=RPbwqLtzDvhoxLIgofTDfwNJ6qxdqObF2wgqiF86dfs,80
 caustic/data/hdf5dataset.py,sha256=yf_qEhaAE_fQTgZXhV5JfPILXrvizjH_NlVzW-GVRtM,1563
 caustic/data/illustris_kappa.py,sha256=OTBtyWAbBID9qkgtaymvpNHSAGh0KeMDiPMXcdP8C5Y,683
 caustic/data/probes.py,sha256=DyOKkkBZ34gcrIG7exm2Cu-HpjsrZv5bczQQas4xiRA,675
 caustic/lenses/__init__.py,sha256=S5Y9lAan0vdfiuVpcElcYt8EasaGB8erMCBsTeruT5M,259
-caustic/lenses/base.py,sha256=SaadVbh9zlxZqbLd2Xdk5WxepgLJ6MN1gsLO_UbW6rA,16300
-caustic/lenses/epl.py,sha256=Pew6RTszdlYuvXTHvwoHe-2BIURu476X5xa5XtovIJg,7457
-caustic/lenses/external_shear.py,sha256=-yhn0gd3KDZOXgfacutFPKQD_4xIQSLwXcrt_vC-vx8,3823
-caustic/lenses/multiplane.py,sha256=5YCyo2pHTF5WmB6x5lla4LewQnSwSZ9WxkphmGAuzp0,5623
-caustic/lenses/nfw.py,sha256=bk05Sf6yBXRf7FK_OzAbaveIIV_U7jXf1o9dsA8tb1Y,10748
-caustic/lenses/pixelated_convergence.py,sha256=kc8kV7UWYTXjvG-LnTacB8HdAoXKe9C01Fd05pPsAgY,14158
-caustic/lenses/point.py,sha256=AwkD4Ex1KTNZPQS2b4Lhq8mka689849IIigA_XpR1Z4,4096
-caustic/lenses/pseudo_jaffe.py,sha256=fzRuSpUAqWjDMfR53F-KtjSi4mKaAFjy6jUoQiImPwI,7740
-caustic/lenses/sie.py,sha256=ZSMZgvEounNqVCiGjRXmE0PrgCF6pCuHd2bMvxSTrJw,4637
-caustic/lenses/singleplane.py,sha256=G4pQyy5KROIHMwgaeyaUr3aILIGU5kcP71uPrgGnNbU,3489
-caustic/lenses/sis.py,sha256=06StBQYIY0QwPERRnL64yZxolaMQshS2XfJF-LJgvrc,3578
+caustic/lenses/base.py,sha256=GifkXoY4X1uR7eFf7uu6F9wfG1ZeuS-fw6SEGryh1SI,16872
+caustic/lenses/epl.py,sha256=XthD8V0469_7jdDgn3FBt08zHHssrQibddAM2Rg7WSg,7487
+caustic/lenses/external_shear.py,sha256=Y2iCZ7wPx3CUHpEs-jP2TiBiDhpTkuEAY1m7wGzYSZQ,3853
+caustic/lenses/multiplane.py,sha256=owkWOJrozH6LaKTK0pAYnSj4FkXntZ3VebEQkuIJeIM,5702
+caustic/lenses/nfw.py,sha256=yBCxCOQhvmKkjv4wruqeg2YajBYWsdyN5kF6hhflwH8,10815
+caustic/lenses/pixelated_convergence.py,sha256=BWV3d1g152ABmycfDGwvQbrGCvURpVyd_CD9G-gjrMw,14289
+caustic/lenses/point.py,sha256=4yy-59VKp7XylSCT9bu43qtkn-KoCbVbvX3xxrtNcYs,4126
+caustic/lenses/pseudo_jaffe.py,sha256=vu4YT1F45Wx8gKzdghoO2NPKggfEcyBKUdqaW9pota8,7790
+caustic/lenses/sie.py,sha256=ngX3CfB8nAcxRdkCp2A25P5yjkEajtAmpIwTo8EtIE0,4667
+caustic/lenses/singleplane.py,sha256=gfYDOHSTlFawjsgWZYzYLoXv8N-Ca2LdZeqmvO5xTpA,3519
+caustic/lenses/sis.py,sha256=4HnkJ08uBNJhorC86E_0l2OeN2PmKhp4gMUBT1Ircsg,3608
 caustic/lenses/utils.py,sha256=-AT-NexgGsmGRcsmElpPmtxd0xkFgELCd70G-bvPf78,2458
 caustic/sources/__init__.py,sha256=_CK3BYNbk-S3yKBGmcbPeKpCe4QHlh6iEwT9UCJuWbU,89
-caustic/sources/base.py,sha256=mHJRfsDS1M0WJLThDCJaZJpT77rW3VqgFLgqDKyEDXI,2000
-caustic/sources/pixelated.py,sha256=b1tB92Y6FtBWJUVmwSH10mNkyn6vHmIUZWrvIx6S5pE,3728
+caustic/sources/base.py,sha256=jjCP_UUGY7sehNqgRbEauZR-X82gF2xrv1vihvVIXrw,2044
+caustic/sources/pixelated.py,sha256=nRCDstWyHqbHnW-nOEsCbqHG6rqKA6s1eSRqGQsLJ1c,3866
 caustic/sources/probes.py,sha256=aNUclNlFTsdGxdwu_dclpRza7scQBHN4AX5hP67oXtc,792
-caustic/sources/sersic.py,sha256=iC_sEz5czUu-Zh5NavjooTot_Lqz1-X5oYx6H3QHhfw,5002
-caustic-0.4.1.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
-caustic-0.4.1.dist-info/METADATA,sha256=BgiJkBu9__mBarBFuyHby2CZd8P9_X-VxTdY4s6HrSs,3393
-caustic-0.4.1.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
-caustic-0.4.1.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
-caustic-0.4.1.dist-info/RECORD,,
+caustic/sources/sersic.py,sha256=_RhEY6Xd8onapDQDVUVU1htdBOBvmh1L7xvSyXVToI0,5012
+caustic-0.4.2.dist-info/LICENSE,sha256=cllh7ggKgLVBj8dXi9pC1mZkHLZlf3xxeLCSJoJIctg,1076
+caustic-0.4.2.dist-info/METADATA,sha256=yBVFBbY7xjMM7wwG6ihX6SLO6o-NfLktNAk3Tj91rKo,3393
+caustic-0.4.2.dist-info/WHEEL,sha256=a-zpFRIJzOq5QfuhBzbhiA1eHTzNCJn8OdRvhdNX0Rk,110
+caustic-0.4.2.dist-info/top_level.txt,sha256=LQoSbW8clrogX400rPniIRZwXwEUKH2gPpPFEhl7ATs,8
+caustic-0.4.2.dist-info/RECORD,,
```

